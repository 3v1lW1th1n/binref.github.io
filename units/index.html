<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>the refinery.units documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:12pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #EEEEEE}#index ul{padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #EEEEEE}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units</code></h1>
</header>
<section id="section-intro">
<p>This package contains all refinery units. To write an executable refinery unit,
it is sufficient to write a class that inherits from <code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code> and
implements <code><a title="refinery.units.Unit.process" href="#refinery.units.Unit.process">Unit.process()</a></code>. If the operation implemented by this
unit should be reversible, then a method called <code>reverse</code> with the same signature
has to be implemented. For example, the following would be a minimalistic
approach to implement <code><a title="refinery.hex" href="../index.html#refinery.hex">hex</a></code>:</p>
<pre><code>from refinery import Unit

class hex(Unit):
    def process(self, data):
        return bytes.fromhex(data.decode('ascii'))

    def reverse(self, data):
        return data.hex().encode(self.codec)
</code></pre>
<p>The above script can be run from the command line. Since <code>hex</code> is not marked as
abstract, its inherited <code><a title="refinery.units.Unit.run" href="#refinery.units.Unit.run">Unit.run()</a></code> method will be invoked when
the script is executed.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L0-L1312" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
This package contains all refinery units. To write an executable refinery unit,
it is sufficient to write a class that inherits from `refinery.units.Unit` and
implements `refinery.units.Unit.process`. If the operation implemented by this
unit should be reversible, then a method called `reverse` with the same signature
has to be implemented. For example, the following would be a minimalistic
approach to implement `refinery.hex`:

    from refinery import Unit

    class hex(Unit):
        def process(self, data):
            return bytes.fromhex(data.decode(&#39;ascii&#39;))

        def reverse(self, data):
            return data.hex().encode(self.codec)

The above script can be run from the command line. Since `hex` is not marked as
abstract, its inherited `refinery.units.Unit.run` method will be invoked when
the script is executed.
&#34;&#34;&#34;
import sys
import os
import io
import inspect

from enum import IntEnum, Enum
from functools import wraps
from collections import OrderedDict
from typing import Iterable, BinaryIO, Union, List, Optional, Callable, Tuple, Any, ByteString
from argparse import (
    ArgumentParser,
    ArgumentError,
    Namespace,
    RawDescriptionHelpFormatter,
    ONE_OR_MORE,
    OPTIONAL,
    REMAINDER,
    SUPPRESS,
    ZERO_OR_MORE
)

from ..lib.argformats import pending, manifest, multibin, number, sliceobj, VariableMissing
from ..lib.tools import terminalfit, get_terminal_size, documentation, lookahead, autoinvoke, skipfirst, isbuffer
from ..lib.frame import Framed, Chunk


class ArgparseError(ValueError):
    &#34;&#34;&#34;
    This custom exception type is thrown from the custom argument parser of
    `refinery.units.Unit` rather than terminating program execution immediately.
    The `parser` parameter is a reference to the argument parser that threw
    the original argument parsing exception with the given `message`.
    &#34;&#34;&#34;
    def __init__(self, parser, message):
        self.parser = parser
        super().__init__(message)


class RefineryPartialResult(ValueError):
    &#34;&#34;&#34;
    This exception indicates that a partial result is available.
    &#34;&#34;&#34;
    def __init__(self, msg, partial):
        super().__init__(msg)
        self.partial = partial


class RefineryCriticalException(RuntimeError):
    &#34;&#34;&#34;
    If this exception is thrown, processing of the entire input stream
    is aborted instead of just aborting the processing of the current
    chunk.
    &#34;&#34;&#34;
    pass


class Entry:
    &#34;&#34;&#34;
    An empty class maker. Any entry point unit (i.e. any unit that can be executed
    via the command line) is an instance of this class.
    &#34;&#34;&#34;
    pass


class Argument:
    &#34;&#34;&#34;
    This class implements an abstract argument to a Python function, including positional
    and keyword arguments. Passing an `Argument` to a Python function can be done via the
    matrix multiplication operator: The syntax `function @ Argument(a, b, kwd=c)` is
    equivalent to the call `function(a, b, kwd=c)`.
    &#34;&#34;&#34;
    __slots__ = &#39;args&#39;, &#39;kwargs&#39;

    def __init__(self, *args, **kwargs):
        self.args = list(args)
        self.kwargs = kwargs

    def __rmatmul__(self, method):
        return method(*self.args, **self.kwargs)

    def __repr__(self):
        def rep(v):
            r = repr(v)
            if r.startswith(&#39;&lt;&#39;):
                try:
                    return v.__name__
                except AttributeError:
                    pass
                try:
                    return v.__class__.__name__
                except AttributeError:
                    pass
            return r
        arglist = [repr(a) for a in self.args]
        arglist.extend(F&#39;{key!s}={rep(value)}&#39; for key, value in self.kwargs.items())
        return &#39;, &#39;.join(arglist)


class arg(Argument):
    &#34;&#34;&#34;
    This child class of `refinery.units.Argument` is specifically an argument for the
    `add_argument` method of an `ArgumentParser` from the `argparse` module. It can also
    be used as a decorator for the constructor of a refinery unit to better control
    the argument parser of that unit&#39;s command line interface. Example:
    ```
    class prefixer(Unit):
        @arg(&#39;prefix&#39;, help=&#39;this data will be prepended to the input.&#39;)
        def __init__(self, prefix): pass

        def process(self, data):
            return self.args.prefix + data
    ```
    Note that when the init of a unit has a return annotation that is a base class of
    itself, then all its parameters will automatically be forwarded to that base class.
    &#34;&#34;&#34;

    class delete: pass
    class omit: pass

    def __init__(
        self, *args: str,
            action   : Union[omit, str]           = omit, # noqa
            choices  : Union[omit, Iterable[Any]] = omit, # noqa
            const    : Union[omit, Any]           = omit, # noqa
            default  : Union[omit, Any]           = omit, # noqa
            dest     : Union[omit, str]           = omit, # noqa
            help     : Union[omit, str]           = omit, # noqa
            metavar  : Union[omit, str]           = omit, # noqa
            nargs    : Union[omit, int, str]      = omit, # noqa
            required : Union[omit, bool]          = omit, # noqa
            type     : Union[omit, type]          = omit, # noqa
            group    : Optional[str]              = None, # noqa
            guess    : bool                       = False # noqa
    ) -&gt; None:
        kwargs = dict(action=action, choices=choices, const=const, default=default, dest=dest,
            help=help, metavar=metavar, nargs=nargs, required=required, type=type)
        kwargs = {key: value for key, value in kwargs.items() if value is not arg.omit}
        self.group = group
        self.guess = guess
        super().__init__(*args, **kwargs)

    def update_help(self):
        if &#39;help&#39; not in self.kwargs:
            return
        formatting = {}
        choices = self.kwargs.get(&#39;choices&#39;, None)
        if choices is not None:
            formatting.update(choices=&#39;, &#39;.join(self.kwargs[&#39;choices&#39;]))
        default = self.kwargs.get(&#39;default&#39;, None)
        if default is not None:
            try:
                formatting.update(default=F&#39;H:{default.hex()}&#39;)
            except AttributeError:
                formatting.update(default=str(default))
        try:
            self.kwargs[&#39;help&#39;] = self.kwargs[&#39;help&#39;].format(**formatting)
        except Exception:
            pass

    def __rmatmul__(self, method):
        self.update_help()
        return super().__rmatmul__(method)

    @staticmethod
    def switch(
        *args: str, off=False,
        help : Union[omit, str] = omit,
        dest : Union[omit, str] = omit,
        group: Optional[str] = None,
    ) -&gt; Argument:
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that change a boolean value from True to False or
        vice versa. By default, a switch will have a False default and change it to True when specified.
        &#34;&#34;&#34;
        return arg(*args, group=group, help=help, dest=dest, action=&#39;store_false&#39; if off else &#39;store_true&#39;)

    @staticmethod
    def number(
        *args: str,
        bound: Union[omit, Tuple[int, int]] = omit,
        help : Union[omit, str] = omit,
        dest : Union[omit, str] = omit,
        metavar : Optional[str] = None,
        group: Optional[str] = None,
    ) -&gt; Argument:
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a number.
        &#34;&#34;&#34;
        nt = number
        if bound is not arg.omit:
            lower, upper = bound
            nt = nt[lower:upper]
        return arg(*args, group=group, help=help, dest=dest, type=nt, metavar=metavar or &#39;N&#39;)

    @staticmethod
    def option(
        *args: str, choices: Enum,
        help : Union[omit, str] = omit,
        dest : Union[omit, str] = omit,
        metavar: Optional[str] = None,
        group: Optional[str] = None,
    ) -&gt; Argument:
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on an enumeration.
        &#34;&#34;&#34;
        cnames = [c.name for c in choices]
        metavar = metavar or choices.__name__
        return arg(*args, group=group, help=help, metavar=metavar, dest=dest, choices=cnames, type=str)

    @staticmethod
    def choice(
        *args: str, choices : List[str],
        help    : Union[omit, str] = omit,
        metavar : Union[omit, str] = omit,
        dest    : Union[omit, str] = omit,
        nargs   : Union[omit, int, str] = omit,
        group   : Optional[str] = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on a list of strings.
        &#34;&#34;&#34;
        return arg(*args, group=group, type=str, metavar=metavar, nargs=nargs,
            dest=dest, help=help, choices=choices)

    @property
    def positional(self) -&gt; bool:
        return any(a[0] != &#39;-&#39; for a in self.args)

    @property
    def destination(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the variable where the contents of this parsed argument will be stored.
        &#34;&#34;&#34;
        for a in self.args:
            if a[0] != &#39;-&#39;:
                return a
        try:
            return self.kwargs[&#39;dest&#39;]
        except KeyError:
            for a in self.args:
                if a.startswith(&#39;--&#39;):
                    dest = a.lstrip(&#39;-&#39;).replace(&#39;-&#39;, &#39;_&#39;)
                    if dest.isidentifier():
                        return dest
            raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)

    @classmethod
    def infer(cls, pt: inspect.Parameter) -&gt; Argument:
        &#34;&#34;&#34;
        This class method can be used to infer the argparse argument for a Python function
        parameter. This guess is based on the annotation, name, and default value.
        &#34;&#34;&#34;

        def needs_type(item):
            return item.get(&#39;action&#39;, &#39;store&#39;) == &#39;store&#39;

        def get_argp_type(annotation_type):
            if issubclass(annotation_type, (bytes, bytearray, memoryview)):
                return multibin
            if issubclass(annotation_type, int):
                return number
            if issubclass(annotation_type, slice):
                return sliceobj
            return annotation_type

        name = pt.name.replace(&#39;_&#39;, &#39;-&#39;)
        default = pt.default
        guessed_pos_args = []
        guessed_kwd_args = dict(dest=pt.name, guess=True)
        annotation = pt.annotation

        if isinstance(annotation, str):
            try: annotation = eval(annotation)
            except Exception: pass

        if annotation is not pt.empty:
            if isinstance(annotation, Argument):
                if annotation.kwargs.get(&#39;dest&#39;, pt.name) != pt.name:
                    raise ValueError(
                        F&#39;Incompatible argument destination specified; parameter {pt.name} &#39;
                        F&#39;was annotated with {annotation!r}.&#39;)
                guessed_pos_args = annotation.args
                guessed_kwd_args.update(annotation.kwargs)
                guessed_kwd_args[&#39;guess&#39;] = False
                guessed_kwd_args[&#39;group&#39;] = annotation.group
            elif isinstance(annotation, type):
                if not issubclass(annotation, bool) and needs_type(guessed_kwd_args):
                    guessed_kwd_args.update(type=get_argp_type(annotation))
                elif not isinstance(default, bool):
                    raise ValueError(&#39;Default value for boolean arguments must be provided.&#39;)

        if not guessed_pos_args:
            guessed_pos_args = guessed_pos_args or [F&#39;--{name}&#39; if pt.kind is pt.KEYWORD_ONLY else name]

        if pt.kind is pt.VAR_POSITIONAL:
            oldnargs = guessed_kwd_args.setdefault(&#39;nargs&#39;, ZERO_OR_MORE)
            if oldnargs not in (ONE_OR_MORE, ZERO_OR_MORE, REMAINDER):
                raise ValueError(F&#39;Variadic positional arguments has nargs set to {oldnargs!r}&#39;)
            return cls(*guessed_pos_args, **guessed_kwd_args)

        if default is not pt.empty:
            if isinstance(default, (list, tuple)):
                guessed_kwd_args.setdefault(&#39;nargs&#39;, ZERO_OR_MORE)
                if not pt.default:
                    default = pt.empty
                else:
                    guessed_kwd_args.setdefault(&#39;default&#39;, pt.default)
                    default = default[0]
            else:
                guessed_kwd_args.setdefault(&#39;default&#39;, default)
                if pt.kind is pt.POSITIONAL_ONLY:
                    guessed_kwd_args.setdefault(&#39;nargs&#39;, OPTIONAL)

        if default is not pt.empty:
            if isinstance(default, bool):
                guessed_kwd_args[&#39;action&#39;] = &#39;store_false&#39; if default else &#39;store_true&#39;
            elif needs_type(guessed_kwd_args) and &#39;type&#39; not in guessed_kwd_args:
                guessed_kwd_args[&#39;type&#39;] = get_argp_type(type(default))

        return cls(*guessed_pos_args, **guessed_kwd_args)

    def merge_args(self, them: Argument) -&gt; None:
        def iterboth():
            yield from them.args
            yield from self.args
        if not self.args:
            self.args = list(them.args)
            return
        sflag = None
        lflag = None
        for a in iterboth():
            if a[:2] == &#39;--&#39;: lflag = lflag or a
            elif a[0] == &#39;-&#39;: sflag = sflag or a
        self.args = []
        if sflag: self.args.append(sflag)
        if lflag: self.args.append(lflag)
        if not self.args:
            self.args = list(them.args)

    def merge_all(self, them: Argument) -&gt; None:
        for key, value in them.kwargs.items():
            if value is arg.delete:
                self.kwargs.pop(key, None)
                continue
            self.kwargs[key] = value
        self.merge_args(them)
        self.guess = self.guess and them.guess
        self.group = self.group or them.group

    def __copy__(self) -&gt; Argument:
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.kwargs = dict(self.kwargs)
        clone.args = list(self.args)
        clone.group = self.group
        clone.guess = self.guess
        return clone

    def __repr__(self) -&gt; str:
        return F&#39;arg({super().__repr__()})&#39;

    def __call__(self, init: Callable) -&gt; Callable:
        parameters = inspect.signature(init).parameters
        try:
            inferred = arg.infer(parameters[self.destination])
            inferred.merge_all(self)
            init.__annotations__[self.destination] = inferred
        except KeyError:
            raise ValueError(F&#39;Unable to decorate because no parameter with name {self.destination} exists.&#39;)
        return init


class ArgumentSpecification(OrderedDict):
    &#34;&#34;&#34;
    A container object that stores `refinery.units.arg` specifications.
    &#34;&#34;&#34;

    def merge(self, argument: arg):
        &#34;&#34;&#34;
        Insert or update the specification with the given argument.
        &#34;&#34;&#34;
        dest = argument.destination
        if dest in self:
            self[dest].merge_all(argument)
            return
        self[dest] = argument


class Executable(type):
    &#34;&#34;&#34;
    This is the metaclass for refinery units. A class which is of this type is
    required to implement a method `run()`. If the class is created in the
    currently executing module, then an instance of the class is automatically
    created after it is defined and its `run()` method is invoked.
    &#34;&#34;&#34;

    Entry = None
    &#34;&#34;&#34;
    This variable stores the executable entry point. If more than one entry point
    are present, only the first one is executed and an error message is generated
    for the other ones.
    &#34;&#34;&#34;

    def _infer_argspec(cls, parameters, args: Optional[ArgumentSpecification] = None):

        args = ArgumentSpecification() if args is None else args
        temp = ArgumentSpecification()

        exposed = [pt.name for pt in skipfirst(parameters.values()) if pt.kind != pt.VAR_KEYWORD]
        # The arguments are added in reverse order to the argument parser later.
        # This is done to have a more intuitive use of decorator based argument configuration.
        exposed.reverse()

        for name in exposed:
            try:
                argument = arg.infer(parameters[name])
            except KeyError:
                continue
            if argument.guess:
                temp.merge(argument)
            else:
                args.merge(argument)

        for guess in temp.values():
            known = args.get(guess.destination, None)
            if known is None:
                args.merge(guess)
                continue
            if not known.positional:
                known.merge_args(guess)
            for k, v in guess.kwargs.items():
                if k == &#39;default&#39;:
                    known.kwargs[k] = v
                else:
                    known.kwargs.setdefault(k, v)

        for name in exposed:
            args.move_to_end(name)

        for known in args.values():
            if known.positional:
                known.kwargs.pop(&#39;dest&#39;, None)
                if &#39;default&#39; in known.kwargs:
                    known.kwargs.setdefault(&#39;nargs&#39;, OPTIONAL)
            elif not any(a.startswith(&#39;--&#39;) for a in known.args):
                flagname = known.destination.replace(&#39;_&#39;, &#39;-&#39;)
                known.args.append(F&#39;--{flagname}&#39;)
            action = known.kwargs.get(&#39;action&#39;, &#39;store&#39;)
            if action.startswith(&#39;store_&#39;):
                known.kwargs.pop(&#39;default&#39;, None)
                continue
            if action == &#39;store&#39;:
                known.kwargs.setdefault(&#39;type&#39;, multibin)
        return args

    def __new__(mcs, name, bases, nmspc, abstract=False):
        def normalize(operation: Callable[[Any, ByteString], Any]) -&gt; Callable[[ByteString], Any]:
            def chunkify(item):
                if isinstance(item, Chunk):
                    return item
                if isinstance(item, dict):
                    return Chunk(item.pop(&#39;data&#39;, None), meta=item)
                return Chunk(item)

            @wraps(operation)
            def wrapped(self, data: ByteString) -&gt; Union[Optional[ByteString], Iterable[ByteString]]:
                if -self.args:
                    if not isinstance(data, bytearray):
                        data = bytearray(data)
                    self.args @= data
                else:
                    try:
                        dt = next(iter(operation.__annotations__.values()))
                        if dt in (bytes, bytearray, memoryview) and not isinstance(data, dt):
                            data = dt(data)
                    except StopIteration:
                        pass
                if wrapped.chunked:
                    return (chunkify(r) for r in operation(self, data))
                return chunkify(operation(self, data))
            wrapped.chunked = inspect.isgeneratorfunction(operation)
            return wrapped

        nmspc.setdefault(&#39;__doc__&#39;, &#39;&#39;)

        for op in (&#39;process&#39;, &#39;reverse&#39;):
            if op in nmspc:
                nmspc[op] = normalize(nmspc[op])

        if not abstract and Entry not in bases:
            bases = bases + (Entry,)

        return super(Executable, mcs).__new__(mcs, name, bases, nmspc)

    def __init__(cls, name, bases, nmspc, abstract=False):
        super(Executable, cls).__init__(name, bases, nmspc)
        parameters = inspect.signature(cls.__init__).parameters
        cls.argspec = ArgumentSpecification()

        if bases:
            parent = bases[0]
            for key, value in parent.argspec.items():
                if not value.guess and key in parameters:
                    cls.argspec[key] = value.__copy__()
            cls._infer_argspec(parameters, cls.argspec)

        if cls.__init__.__code__.co_code == (lambda: None).__code__.co_code:
            base = bases[0]
            head = []
            defs = {}
            tail = None

            for p in skipfirst(parameters.values()):
                if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD):
                    head.append(p.name)
                if p.kind in (p.KEYWORD_ONLY, p.POSITIONAL_OR_KEYWORD) and p.default is not p.empty:
                    defs[p.name] = p.default
                if p.kind is p.VAR_POSITIONAL:
                    tail = p.name

            @wraps(cls.__init__)
            def cls__init__(self, *args, **kw):
                for name, arg in zip(head, args):
                    kw[name] = arg
                if tail:
                    k = min(len(args), len(head))
                    kw[tail] = args[k:]
                for key in defs:
                    if key not in kw:
                        kw[key] = defs[key]
                base.__init__(self, **kw)

            cls.__init__ = cls__init__

        if not abstract and sys.modules[cls.__module__].__name__ == &#39;__main__&#39;:
            if Executable.Entry:
                cls._output(
                    F&#39;not executing this unit because the following unit was &#39;
                    F&#39;already executed: {Executable.Entry}&#39;
                )
            else:
                Executable.Entry = cls.name
                cls.run()

    def __getitem__(cls, other):
        return cls().__getitem__(other)

    def __or__(cls, other):
        return cls().__or__(other)

    def __ror__(cls, other):
        return cls().__ror__(other)

    @property
    def is_reversible(cls) -&gt; bool:
        &#34;&#34;&#34;
        This property is `True` if and only if the unit has a member function
        named `reverse`. By convention, this member function implements the
        inverse of `refinery.units.Unit.process`.
        &#34;&#34;&#34;
        return hasattr(cls, &#39;reverse&#39;)

    @property
    def codec(cls) -&gt; str:
        &#34;&#34;&#34;
        The default codec for encoding textual information between units.
        The value of this property is hardcoded to `UTF8`.
        &#34;&#34;&#34;
        return &#39;UTF8&#39;

    @property
    def name(cls) -&gt; str:
        return cls.__name__.replace(&#39;_&#39;, &#39;-&#39;)


class LogLevel(IntEnum):
    &#34;&#34;&#34;
    An enumeration representing the current log level:
    &#34;&#34;&#34;
    DETACHED = -1
    &#34;&#34;&#34;
    This unit is not attached to a terminal but has been instantiated in
    code. This means that the only way to communicate problems is to throw
    an exception.
    &#34;&#34;&#34;
    NONE = 0
    &#34;&#34;&#34;
    Do not log anything.
    &#34;&#34;&#34;
    WARN = 1
    &#34;&#34;&#34;
    Default log level: Log warnings.
    &#34;&#34;&#34;
    INFO = 2
    &#34;&#34;&#34;
    Increased logging.
    &#34;&#34;&#34;
    DEBUG = 3
    &#34;&#34;&#34;
    Maximum logging.
    &#34;&#34;&#34;


class DelayedArgumentProxy:
    &#34;&#34;&#34;
    This class implements a proxy for the `args` member variable of `refinery.units.Unit`.
    Its primary purpose is to proxy `refinery.lib.argformats.DelayedArgument` values which
    can be computed only as soon as input data becomes available and which also have to be
    recomputed for each input.
    &#34;&#34;&#34;

    def __copy__(self):
        cls = self.__class__
        clone = cls.__new__(cls)
        clone._store(
            _argv=self._argv,
            _argo=list(self._argo),
            _args=dict(self._args),
            _done=self._done,
            _guid=self._guid,
        )
        return clone

    def __init__(self, argv, argo):
        args = {}
        done = True
        for name, value in vars(argv).items():
            if not pending(value):
                args[name] = value
            else:
                done = False
        self._store(
            _argv=argv,
            _argo=list(argo),
            _args=args,
            _done=done,
            _guid=None,
        )

    def __neg__(self):
        return not self._done

    def __imatmul__(self, data: bytearray):
        &#34;&#34;&#34;
        Lock the current arguments for the given input `data`.
        &#34;&#34;&#34;
        identifier = id(data)
        if not self._done and identifier != self._guid:
            self._store(_guid=identifier)
            for name in self._argo:
                value = getattr(self._argv, name, None)
                if value and pending(value):
                    self._args[name] = manifest(value, data)
        return self

    def _store(self, **kwargs):
        self.__dict__.update(kwargs)

    def __getattr__(self, name):
        try:
            return super().__getattr__(name)
        except AttributeError:
            pass
        try:
            return self._args[name]
        except KeyError:
            pass
        try:
            value = getattr(self._argv, name)
        except AttributeError as E:
            raise AttributeError(F&#39;Argument {name} not set.&#39;) from E
        if not value or not pending(value):
            return value
        raise AttributeError(F&#39;the value {name} cannot be accessed until data is available.&#39;)

    def __setattr__(self, name, value):
        if not hasattr(self._argv, name):
            self._argo.append(name)
        if pending(value):
            self._store(_done=False)
        else:
            self._args[name] = value
        return setattr(self._argv, name, value)


class Unit(metaclass=Executable, abstract=True):
    &#34;&#34;&#34;
    The base class for all refinery units. It implements a small set of globally
    available options and the handling for multiple inputs and outputs. All units
    implement the _framing_ syntax for producing multiple outputs and ingesting
    multiple inputs in a common format. For more details, see `refinery.lib.frame`.
    &#34;&#34;&#34;
    @property
    def is_reversible(self) -&gt; bool:
        return self.__class__.is_reversible

    @property
    def codec(self) -&gt; str:
        return self.__class__.codec

    @property
    def name(self) -&gt; str:
        return self.__class__.name

    @property
    def log_level(self) -&gt; LogLevel:
        &#34;&#34;&#34;
        Returns the current log level as an element of `refinery.units.LogLevel`.
        &#34;&#34;&#34;
        try:
            return LogLevel.NONE if self.args.quiet else LogLevel(min(len(LogLevel) - 2, self.args.verbose))
        except AttributeError:
            return LogLevel.DETACHED

    @log_level.setter
    def log_level(self, value: LogLevel) -&gt; None:
        self.args.verbose = int(value)

    def log_detach(self) -&gt; None:
        self.log_level = LogLevel.DETACHED
        self.args.quiet = False

    def __iter__(self):
        return self

    def _exception_handler(self, exception: BaseException):
        if self.log_level &lt;= LogLevel.DETACHED:
            raise
        elif isinstance(exception, RefineryCriticalException):
            self.log_warn(F&#39;critical error, terminating: {exception}&#39;)
            raise
        elif isinstance(exception, VariableMissing):
            self.log_warn(&#39;critical error:&#39;, exception)
            raise RefineryCriticalException
        elif isinstance(exception, GeneratorExit):
            raise
        elif isinstance(exception, RefineryPartialResult):
            if not self.log_level:
                return None
            elif not self.log_warn(F&#39;error, partial result returned: {exception}&#39;):
                raise exception
            return exception.partial
        else:
            self.log_warn(F&#39;unexpected exception of type {exception.__class__.__name__}; {exception!s}&#39;)

        if self.log_debug():
            import traceback
            traceback.print_exc(file=sys.stderr)

    def __next__(self):
        if not self._chunks:
            self._chunks = iter(self._framehandler)
        while True:
            try:
                return next(self._chunks)
            except RefineryCriticalException as R:
                raise StopIteration from R

    @property
    def _framehandler(self) -&gt; Framed:
        if self._framed:
            return self._framed

        op = self.reverse if self.args.reverse else self.process

        def normalized_action(data: ByteString) -&gt; Iterable[ByteString]:
            try:
                result = op(data)
                if inspect.isgenerator(result):
                    yield from filter(lambda x: x is not None, result)
                elif result is not None:
                    yield result
            except BaseException as B:
                result = self._exception_handler(B)
                if result is not None:
                    yield result

        self._framed = Framed(
            normalized_action,
            self.source,
            self.args.nesting,
            self.filter
        )
        return self._framed

    def filter(self, inputs: Iterable[Chunk]) -&gt; Iterable[Chunk]:
        &#34;&#34;&#34;
        Receives an iterable of `refinery.lib.frame.Chunk`s and yields only those that
        should be processed. The default implementation returns the iterator without
        change; this member function is designed to be overloaded by child classes of
        `refinery.units.Unit` to allow inspection of an entire frame layer and altering
        it before `refinery.units.Unit.process` is called on the individual chunks.
        &#34;&#34;&#34;
        return inputs

    @property
    def source(self):
        &#34;&#34;&#34;
        Represents a unit or binary IO stream which has been attached to this unit as its
        source of input data.
        &#34;&#34;&#34;
        return self._source

    @source.setter
    def source(self, stream):
        if isinstance(stream, self.__class__.__class__):
            stream = stream()
        if not isinstance(stream, self.__class__):
            self._framed = None
            self._chunks = None
        self._source = stream

    @property
    def nozzle(self) -&gt; &#39;Unit&#39;:
        &#34;&#34;&#34;
        The nozzle is defined recursively as the nozzle of `refinery.units.Unit.source`
        and `self` if no such thing exists. In other words, it is the leftmost unit in
        a pipeline, where data should be inserted for processing.
        &#34;&#34;&#34;
        try:
            return self.source.nozzle
        except AttributeError:
            return self

    def __getitem__(self, unit: &#39;Unit&#39;):
        if isinstance(unit, type):
            unit = unit()
        alpha = self.__copy__()
        omega = unit.__copy__()
        alpha.args.nesting += 1
        omega.args.nesting -= 1
        omega.nozzle.source = alpha
        return omega

    def __ror__(self, stream: Union[BinaryIO, ByteString]):
        if not isbuffer(stream):
            self.nozzle.source = stream
            return self
        return self(stream)

    def __or__(self, stream: Union[BinaryIO, &#39;Unit&#39;]):
        try:
            if isinstance(stream, type):
                stream = stream()
            return stream.__copy__().__ror__(self)
        except AttributeError:
            self._target = stream

        if not self._target.writable():
            return

        def cname(x): return x.lower().replace(&#39;-&#39;, &#39;&#39;)

        if self.isatty and cname(self.codec) != cname(sys.stdout.encoding):
            def recode(chunk):
                import codecs
                return codecs.encode(
                    codecs.decode(chunk, self.codec, errors=&#39;backslashreplace&#39;),
                    sys.stdout.encoding
                )
        else:
            def recode(chunk): return chunk

        for last, chunk in lookahead(self):
            if (
                not last
                and (self._framehandler.unframed or self._framehandler.framebreak)
                and not chunk.endswith(B&#39;\n&#39;)
                and not self.args.squeeze
            ):
                chunk += B&#39;\n&#39;
            try:
                self._target.write(recode(chunk))
                self._target.flush()
            except AttributeError:
                pass
            except (BrokenPipeError, OSError) as E:
                if isinstance(E, BrokenPipeError) or E.errno != 32:
                    # This happens when the next unit does not consume everything
                    # we send. For example, this can happen when a large file is
                    # read in chunks and the pick unit is used to select only the
                    # first few of these.
                    self.log_info(F&#39;cannot send to next unit: {E}&#39;)
                break

        try:
            if self.isatty and not chunk.endswith(B&#39;\n&#39;):
                self._target.write(B&#39;\n&#39;)
                self._target.flush()
        except (NameError, AttributeError):
            pass

        return self._target

    def read(self, bytecount: int = -1) -&gt; bytes:
        &#34;&#34;&#34;
        Reads bytes from the output stream of this unit.
        &#34;&#34;&#34;
        if not bytecount or bytecount &lt; 0:
            return self.read1()
        bfr = bytearray(bytecount)
        offset = 0
        while offset &lt; bytecount:
            tmp = self.read1(bytecount - offset)
            if not tmp:
                del bfr[offset:]
                break
            end = offset + len(tmp)
            bfr[offset:end] = tmp
            offset = end
        return bytes(bfr)

    def read1(self, bytecount: int = -1) -&gt; bytes:
        &#34;&#34;&#34;
        Performs a single read against the output stream of this unit and returns
        the result.
        &#34;&#34;&#34;
        try:
            out = self._buffer or next(self)
            if bytecount and bytecount &gt; 0:
                out, self._buffer = out[:bytecount], out[bytecount:]
            elif self._buffer:
                self._buffer = B&#39;&#39;
            return out
        except StopIteration:
            return B&#39;&#39;

    def __call__(self, data: Optional[ByteString] = None) -&gt; bytes:
        with io.BytesIO(data) if data else open(os.devnull, &#39;rb&#39;) as stdin:
            with io.BytesIO() as stdout:
                return (stdin | self | stdout).getvalue()

    def process(self, data: ByteString) -&gt; Union[Optional[ByteString], Iterable[ByteString]]:
        &#34;&#34;&#34;
        This routine is overridden by children of `refinery.units.Unit` to define how
        the unit processes a given chunk of binary data.
        &#34;&#34;&#34;
        return data

    def log_warn(self, *messages) -&gt; bool:
        &#34;&#34;&#34;
        Call `refinery.units.Unit.output` for each provided message if and only if the
        current log level is at least `refinery.units.LogLevel.WARN`.
        &#34;&#34;&#34;
        rv = self.log_level &gt;= LogLevel.WARN
        if rv and messages:
            self.output(*messages)
        return rv

    def log_info(self, *messages) -&gt; bool:
        &#34;&#34;&#34;
        Call `refinery.units.Unit.output` for each provided message if and only if the
        current log level is at least `refinery.units.LogLevel.INFO`.
        &#34;&#34;&#34;
        rv = self.log_level &gt;= LogLevel.INFO
        if rv and messages:
            self.output(*messages)
        return rv

    def log_debug(self, *messages) -&gt; bool:
        &#34;&#34;&#34;
        Call `refinery.units.Unit.output` for each provided message if and only if the
        current log level is at least `refinery.units.LogLevel.DEBUG`.
        &#34;&#34;&#34;
        rv = self.log_level &gt;= LogLevel.DEBUG
        if rv and messages:
            self.output(*messages)
        return rv

    def output(self, *messages) -&gt; None:
        &#34;&#34;&#34;
        Logs the provided messages to stderr, prefixed with the current unit&#39;s name.
        The routine accepts both string and byte type arguments. Bytestrings are
        decoded with the default codec, using the &#39;backslashreplace&#39; error handler.
        Does not produce any output if the quiet switch has been enabled via the
        command line arguments.
        &#34;&#34;&#34;
        if not self.args.quiet:
            return self._output(*messages)

    @property
    def isatty(self) -&gt; bool:
        try:
            return self._target.isatty()
        except AttributeError:
            return False

    @classmethod
    def _output(cls, *messages) -&gt; None:
        def transform(x):
            try: x = x()
            except TypeError: pass
            if isinstance(x, str):
                return x
            if isinstance(x, (bytes, bytearray, memoryview)):
                import codecs
                return codecs.decode(x, cls.codec, errors=&#39;backslashreplace&#39;)
            return str(x)
        message = &#39; &#39;.join(transform(msg) for msg in messages)
        print(F&#39;{cls.name}: {message}&#39;, file=sys.stderr)

    @classmethod
    def _interface(cls, argp: ArgumentParser) -&gt; ArgumentParser:
        &#34;&#34;&#34;
        Receives a reference to an `ArgumentParser` object. This parser will be used to parse
        the command line for this unit into the member variable called `args`.
        &#34;&#34;&#34;
        base = argp.add_argument_group(&#39;generic options&#39;)

        base.add_argument(&#39;-h&#39;, &#39;--help&#39;, action=&#39;help&#39;, help=&#39;Show this help message and exit.&#39;)
        base.set_defaults(reverse=False, squeeze=False)

        if cls.is_reversible:
            base.add_argument(&#39;-R&#39;, &#39;--reverse&#39;, action=&#39;store_true&#39;, help=&#39;Use the reverse operation.&#39;)

        if cls.process.chunked or (cls.is_reversible and cls.reverse.chunked):
            base.add_argument(&#39;-Z&#39;, &#39;--squeeze&#39;, action=&#39;store_true&#39;, help=&#39;Fuse outputs, do not insert line breaks.&#39;)

        base.add_argument(&#39;-Q&#39;, &#39;--quiet&#39;, action=&#39;store_true&#39;, help=&#39;Disables all log output.&#39;)
        base.add_argument(&#39;-0&#39;, &#39;--devnull&#39;, action=&#39;store_true&#39;, help=&#39;Do not produce any output.&#39;)
        base.add_argument(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;count&#39;, default=LogLevel.WARN,
            help=&#39;Specify up to two times to increase log level.&#39;)
        argp.add_argument(&#39;--debug-timing&#39;, dest=&#39;dtiming&#39;, action=&#39;store_true&#39;, help=SUPPRESS)

        groups = {None: argp}

        for argument in reversed(cls.argspec.values()):
            gp = argument.group
            if gp not in groups:
                groups[gp] = argp.add_mutually_exclusive_group()
            groups[gp].add_argument @ argument

        return argp

    @classmethod
    def argparser(cls, *args, **keywords):
        cols = get_terminal_size()
        args = list(args)

        class ArgumentParserWithKeywordHooks(ArgumentParser):
            def _add_action(self, action):

                class RememberOrder:
                    def __getattr__(self, name): return getattr(action, name)
                    def __setattr__(self, name, value): return setattr(action, name, value)

                    def __call__(self, parser, ns, values, opt=None):
                        if self.dest not in parser.order:
                            parser.order.append(self.dest)
                        return action(parser, ns, values, opt)

                if action.dest in keywords:
                    action.required = False
                    if callable(getattr(action, &#39;type&#39;, None)):
                        value = keywords[action.dest]
                        if value is not None and isinstance(value, str) and action.type is not str:
                            keywords[action.dest] = action.type(keywords[action.dest])

                return super()._add_action(RememberOrder())

            def _parse_optional(self, arg_string):
                if isinstance(arg_string, str):
                    return super()._parse_optional(arg_string)

            def error_commandline(self, message):
                super().error(message)

            def error(self, message):
                parser_instance = self
                raise ArgparseError(parser_instance, message)

            def parse_args(self):
                self.order = []
                args_for_parser = args
                if args and args[~0] and isinstance(args[~0], str):
                    nestarg = args[~0]
                    nesting = len(nestarg)
                    if nestarg == &#39;]&#39; * nesting:
                        self.set_defaults(nesting=-nesting)
                        args_for_parser = args[:~0]
                    elif nestarg == &#39;[&#39; * nesting:
                        self.set_defaults(nesting=nesting)
                        args_for_parser = args[:~0]
                self.set_defaults(**keywords)
                try:
                    parsed = super().parse_args(args=args_for_parser)
                except ArgumentError as e:
                    self.error(str(e))
                for name in keywords:
                    param = getattr(parsed, name, None)
                    if param != keywords[name]:
                        self.error(
                            F&#39;parameter &#34;{name}&#34; duplicated with conflicting &#39;
                            F&#39;values {param} and {keywords[name]}&#39;
                        )
                for name in vars(parsed):
                    if name not in self.order:
                        self.order.append(name)
                return parsed

        class LineWrapRawTextHelpFormatter(RawDescriptionHelpFormatter):
            def __init__(self, prog, indent_increment=2, max_help_position=30, width=None):
                super().__init__(prog, indent_increment, max_help_position, width=cols)

            def add_text(self, text):
                if isinstance(text, str):
                    text = terminalfit(text, width=cols)
                return super().add_text(text)

            def _format_action_invocation(self, action):
                if not action.option_strings:
                    metavar, = self._metavar_formatter(action, action.dest)(1)
                    return metavar
                else:
                    parts = []
                    if action.nargs == 0:
                        parts.extend(action.option_strings)
                    else:
                        default = action.dest.upper()
                        args_string = self._format_args(action, default)
                        for option_string in action.option_strings:
                            parts.append(str(option_string))
                        parts[-1] += F&#39; {args_string}&#39;
                    return &#39;, &#39;.join(parts)

        argp = ArgumentParserWithKeywordHooks(
            prog=cls.name,
            description=documentation(cls),
            formatter_class=LineWrapRawTextHelpFormatter,
            add_help=False
        )

        argp.set_defaults(nesting=0)
        return cls._interface(argp)

    @staticmethod
    def superinit(spc, **keywords):
        &#34;&#34;&#34;
        This function uses `refinery.lib.tools.autoinvoke` to call the `__init__` function of `super` with
        by taking all required parameters from `keywords`, ignoring the rest. Calling
        ```
        self.superinit(super(), **vars())
        ```
        will therefore perform initialization of the parent class without having to forward all parameters
        manually. This is a convenience feature which reduces code bloat when many parameters have to be
        forwarded, see e.g. `refinery.units.pattern.carve.carve` for an example.
        &#34;&#34;&#34;
        args = inspect.signature(spc.__thisclass__.__init__).parameters
        keep = list(skipfirst(args))
        junk = [a for a in keywords if a not in keep]
        for j in junk: del keywords[j]
        for a in args.values():
            if a.kind is a.VAR_KEYWORD:
                keywords.update(keywords.pop(a.name, {}))
        try:
            if spc.__init__.__func__ is Unit.__init__:
                return spc.__init__(**keywords)
        except AttributeError:
            pass
        return autoinvoke(spc.__init__, keywords)

    @classmethod
    def assemble(cls, *args, **keywords):
        &#34;&#34;&#34;
        Creates a unit from the given arguments and keywords. The given keywords are used to overwrite any
        previously specified defaults for the argument parser of the unit, then this modified parser is
        used to parse the given list of arguments as though they were given on the command line. The parser
        results are used to construct an instance of the unit, this object is consequently returned.
        &#34;&#34;&#34;
        argp = cls.argparser(*args, **keywords)
        args = argp.parse_args()

        try:
            unit = autoinvoke(cls, args.__dict__)
        except ValueError as E:
            argp.error(str(E))

        unit.args._store(_argo=argp.order)
        unit.args.quiet = args.quiet

        unit.args.squeeze = args.squeeze
        unit.args.dtiming = args.dtiming
        unit.args.nesting = args.nesting
        unit.args.reverse = args.reverse
        unit.args.devnull = args.devnull
        unit.args.verbose = args.verbose

        return unit

    def __copy__(self):
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.__dict__.update(self.__dict__)
    #   TODO: Preferably, units should keep all their information in args, making
    #         the above __dict__ update unnecessary.
    #   clone._buffer = self._buffer
    #   clone._source = self._source
        clone._target = None
        clone._framed = None
        clone._chunks = None
        clone.args = self.args.__copy__()
        return clone

    def __init__(self, **keywords):
        self._buffer = B&#39;&#39;
        self._source = None
        self._target = None
        self._framed = None
        self._chunks = None

        keywords.update(dict(
            dtiming=False,
            nesting=0,
            reverse=False,
            squeeze=False,
            devnull=False,
            verbose=LogLevel.DETACHED,
            quiet=False,
        ))
        # Since Python 3.6, functions always preserve the order of the keyword
        # arguments passed to them (see PEP 468).
        self.args = DelayedArgumentProxy(Namespace(**keywords), list(keywords))

    def detach(self):
        &#34;&#34;&#34;
        When a unit is created using the `refinery.units.Unit.assemble` method, it is attached to a
        logger by default (in less abstract terms, the `refinery.units.Unit.log_level` property is
        set to a positive value). This method detaches the unit from its logger, which also means that
        any exceptions that occur during runtime will be raised to the caller.
        &#34;&#34;&#34;
        self.log_level = LogLevel.DETACHED
        return self

    @classmethod
    def run(cls, argv=None, stream=None) -&gt; None:
        &#34;&#34;&#34;
        Implements command line execution. As `refinery.units.Unit` is an `refinery.units.Executable`,
        this method will be executed when a class inheriting from `refinery.units.Unit` is defined in
        the current `__main__` module.
        &#34;&#34;&#34;
        argv = argv if argv is not None else sys.argv[1:]

        if stream is None:
            stream = open(os.devnull, &#39;rb&#39;) if sys.stdin.isatty() else sys.stdin.buffer

        with stream as source:
            try:
                unit = cls.assemble(*argv)
            except ArgparseError as ap:
                ap.parser.error_commandline(str(ap))
            except Exception as msg:
                cls._output(&#39;initialization failed:&#39;, msg)
                return

            try:
                loglevel = os.environ[&#39;REFINERY_VERBOSITY&#39;]
            except KeyError:
                pass
            else:
                try:
                    loglevel = LogLevel[loglevel]
                except KeyError:
                    loglevels = &#39;, &#39;.join(ll.name for ll in LogLevel)
                    unit.log_warn(F&#39;unknown verbosity {loglevel!r}, pick from {loglevels}&#39;)
                else:
                    unit.log_level = loglevel

            if unit.args.dtiming:
                from time import process_time
                start_clock = process_time()
                unit.output(&#39;starting clock: {:.4f}&#39;.format(start_clock))

            try:
                with open(os.devnull, &#39;wb&#39;) if unit.args.devnull else sys.stdout.buffer as output:
                    source | unit | output
            except KeyboardInterrupt:
                unit.output(&#39;aborting due to keyboard interrupt&#39;)
            except OSError:
                pass

            if unit.args.dtiming:
                stop_clock = process_time()
                unit.output(&#39;stopping clock: {:.4f}&#39;.format(stop_clock))
                unit.output(&#39;time delta was: {:.4f}&#39;.format(stop_clock - start_clock))


__pdoc__ = {
    &#39;Unit.is_reversible&#39;: Executable.is_reversible.__doc__,
    &#39;Unit.codec&#39;: Executable.codec.__doc__
}</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="refinery.units.blockwise" href="blockwise/index.html">refinery.units.blockwise</a></code></dt>
<dd>
<section class="desc"><p>Contains all units that can work on blocks a fixed length. Note that block cipher
algorithms can be found in <code><a title="refinery.units.crypto.cipher" href="crypto/cipher/index.html">refinery.units.crypto.cipher</a></code>.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.compression" href="compression/index.html">refinery.units.compression</a></code></dt>
<dd>
<section class="desc"><p>A collection of compression algorithms. The unit <code><a title="refinery.decompress" href="../index.html#refinery.decompress">decompress</a></code>
implements a brute force heuristic decompressor that attempts all known
</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto" href="crypto/index.html">refinery.units.crypto</a></code></dt>
<dd>
<section class="desc"><p>Cryptographic routines, cipher and key derivation units.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.encoding" href="encoding/index.html">refinery.units.encoding</a></code></dt>
<dd>
<section class="desc"><p>Encoding and decoding of various formats.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats" href="formats/index.html">refinery.units.formats</a></code></dt>
<dd>
<section class="desc"><p>A package containing several sub-packages for various data formats.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.meta" href="meta/index.html">refinery.units.meta</a></code></dt>
<dd>
<section class="desc"><p>A package for units that operate primarily on frames of several of inputs.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.misc" href="misc/index.html">refinery.units.misc</a></code></dt>
<dd>
<section class="desc"><p>Units whose purpose is narrow or very special and does not fit well into any
other category.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.obfuscation" href="obfuscation/index.html">refinery.units.obfuscation</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern" href="pattern/index.html">refinery.units.pattern</a></code></dt>
<dd>
<section class="desc"><p>Pattern matching based extraction and substitution units.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.shortcuts" href="shortcuts/index.html">refinery.units.shortcuts</a></code></dt>
<dd>
<section class="desc"><p>The units in this package are aliases to certain combinations of other refinery
units.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.sinks" href="sinks/index.html">refinery.units.sinks</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.strings" href="strings/index.html">refinery.units.strings</a></code></dt>
<dd>
<section class="desc"><p>Simple operations on strings, such as concatenation, replacement, slicing,
trimming, etcetera.</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.ArgparseError"><code class="flex name class">
<span>class <span class="ident">ArgparseError</span></span>
<span>(</span><span>parser, message)</span>
</code></dt>
<dd>
<section class="desc"><p>This custom exception type is thrown from the custom argument parser of
<code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code> rather than terminating program execution immediately.
The <code>parser</code> parameter is a reference to the argument parser that threw
the original argument parsing exception with the given <code>message</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L50-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ArgparseError(ValueError):
    &#34;&#34;&#34;
    This custom exception type is thrown from the custom argument parser of
    `refinery.units.Unit` rather than terminating program execution immediately.
    The `parser` parameter is a reference to the argument parser that threw
    the original argument parsing exception with the given `message`.
    &#34;&#34;&#34;
    def __init__(self, parser, message):
        self.parser = parser
        super().__init__(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.units.RefineryPartialResult"><code class="flex name class">
<span>class <span class="ident">RefineryPartialResult</span></span>
<span>(</span><span>msg, partial)</span>
</code></dt>
<dd>
<section class="desc"><p>This exception indicates that a partial result is available.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L62-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RefineryPartialResult(ValueError):
    &#34;&#34;&#34;
    This exception indicates that a partial result is available.
    &#34;&#34;&#34;
    def __init__(self, msg, partial):
        super().__init__(msg)
        self.partial = partial</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>refinery.units.obfuscation.AutoDeobfuscationTimeout</li>
</ul>
</dd>
<dt id="refinery.units.RefineryCriticalException"><code class="flex name class">
<span>class <span class="ident">RefineryCriticalException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>If this exception is thrown, processing of the entire input stream
is aborted instead of just aborting the processing of the current
chunk.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L71-L77" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RefineryCriticalException(RuntimeError):
    &#34;&#34;&#34;
    If this exception is thrown, processing of the entire input stream
    is aborted instead of just aborting the processing of the current
    chunk.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.RuntimeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.units.Entry"><code class="flex name class">
<span>class <span class="ident">Entry</span></span>
</code></dt>
<dd>
<section class="desc"><p>An empty class maker. Any entry point unit (i.e. any unit that can be executed
via the command line) is an instance of this class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L80-L85" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Entry:
    &#34;&#34;&#34;
    An empty class maker. Any entry point unit (i.e. any unit that can be executed
    via the command line) is an instance of this class.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.blockwise.add.add" href="blockwise/add.html#refinery.units.blockwise.add.add">add</a></li>
<li><a title="refinery.units.blockwise.bitrev.bitrev" href="blockwise/bitrev.html#refinery.units.blockwise.bitrev.bitrev">bitrev</a></li>
<li><a title="refinery.units.blockwise.blockop.blockop" href="blockwise/blockop.html#refinery.units.blockwise.blockop.blockop">blockop</a></li>
<li><a title="refinery.units.blockwise.map.map" href="blockwise/map.html#refinery.units.blockwise.map.map">map</a></li>
<li><a title="refinery.units.blockwise.neg.neg" href="blockwise/neg.html#refinery.units.blockwise.neg.neg">neg</a></li>
<li><a title="refinery.units.blockwise.pack.pack" href="blockwise/pack.html#refinery.units.blockwise.pack.pack">pack</a></li>
<li><a title="refinery.units.blockwise.rev.rev" href="blockwise/rev.html#refinery.units.blockwise.rev.rev">rev</a></li>
<li><a title="refinery.units.blockwise.rotl.rotl" href="blockwise/rotl.html#refinery.units.blockwise.rotl.rotl">rotl</a></li>
<li><a title="refinery.units.blockwise.rotr.rotr" href="blockwise/rotr.html#refinery.units.blockwise.rotr.rotr">rotr</a></li>
<li><a title="refinery.units.blockwise.shl.shl" href="blockwise/shl.html#refinery.units.blockwise.shl.shl">shl</a></li>
<li><a title="refinery.units.blockwise.shr.shr" href="blockwise/shr.html#refinery.units.blockwise.shr.shr">shr</a></li>
<li><a title="refinery.units.blockwise.sub.sub" href="blockwise/sub.html#refinery.units.blockwise.sub.sub">sub</a></li>
<li><a title="refinery.units.blockwise.transpose.transpose" href="blockwise/transpose.html#refinery.units.blockwise.transpose.transpose">transpose</a></li>
<li><a title="refinery.units.blockwise.xor.xor" href="blockwise/xor.html#refinery.units.blockwise.xor.xor">xor</a></li>
<li><a title="refinery.units.compression.ap.aplib" href="compression/ap.html#refinery.units.compression.ap.aplib">aplib</a></li>
<li><a title="refinery.units.compression.bz2.bz2" href="compression/bz2.html#refinery.units.compression.bz2.bz2">bz2</a></li>
<li><a title="refinery.units.compression.decompress.decompress" href="compression/decompress.html#refinery.units.compression.decompress.decompress">decompress</a></li>
<li><a title="refinery.units.compression.gz.gz" href="compression/gz.html#refinery.units.compression.gz.gz">gz</a></li>
<li><a title="refinery.units.compression.lz.lzma" href="compression/lz.html#refinery.units.compression.lz.lzma">lzma</a></li>
<li><a title="refinery.units.compression.lznt1.lznt1" href="compression/lznt1.html#refinery.units.compression.lznt1.lznt1">lznt1</a></li>
<li><a title="refinery.units.compression.zl.zl" href="compression/zl.html#refinery.units.compression.zl.zl">zl</a></li>
<li><a title="refinery.units.crypto.cipher.aes.aes" href="crypto/cipher/aes.html#refinery.units.crypto.cipher.aes.aes">aes</a></li>
<li><a title="refinery.units.crypto.cipher.blowfish.blowfish" href="crypto/cipher/blowfish.html#refinery.units.crypto.cipher.blowfish.blowfish">blowfish</a></li>
<li><a title="refinery.units.crypto.cipher.cast.cast" href="crypto/cipher/cast.html#refinery.units.crypto.cipher.cast.cast">cast</a></li>
<li><a title="refinery.units.crypto.cipher.chacha.chacha" href="crypto/cipher/chacha.html#refinery.units.crypto.cipher.chacha.chacha">chacha</a></li>
<li><a title="refinery.units.crypto.cipher.des.des" href="crypto/cipher/des.html#refinery.units.crypto.cipher.des.des">des</a></li>
<li><a title="refinery.units.crypto.cipher.des3.des3" href="crypto/cipher/des3.html#refinery.units.crypto.cipher.des3.des3">des3</a></li>
<li><a title="refinery.units.crypto.cipher.hc128.hc128" href="crypto/cipher/hc128.html#refinery.units.crypto.cipher.hc128.hc128">hc128</a></li>
<li><a title="refinery.units.crypto.cipher.rc2.rc2" href="crypto/cipher/rc2.html#refinery.units.crypto.cipher.rc2.rc2">rc2</a></li>
<li><a title="refinery.units.crypto.cipher.rc4.rc4" href="crypto/cipher/rc4.html#refinery.units.crypto.cipher.rc4.rc4">rc4</a></li>
<li><a title="refinery.units.crypto.cipher.rncrypt.rncrypt" href="crypto/cipher/rncrypt.html#refinery.units.crypto.cipher.rncrypt.rncrypt">rncrypt</a></li>
<li><a title="refinery.units.crypto.cipher.rot.rot" href="crypto/cipher/rot.html#refinery.units.crypto.cipher.rot.rot">rot</a></li>
<li><a title="refinery.units.crypto.cipher.rsa.rsa" href="crypto/cipher/rsa.html#refinery.units.crypto.cipher.rsa.rsa">rsa</a></li>
<li><a title="refinery.units.crypto.cipher.salsa.salsa" href="crypto/cipher/salsa.html#refinery.units.crypto.cipher.salsa.salsa">salsa</a></li>
<li><a title="refinery.units.crypto.cipher.seal.seal" href="crypto/cipher/seal.html#refinery.units.crypto.cipher.seal.seal">seal</a></li>
<li><a title="refinery.units.crypto.cipher.secstr.secstr" href="crypto/cipher/secstr.html#refinery.units.crypto.cipher.secstr.secstr">secstr</a></li>
<li><a title="refinery.units.crypto.cipher.vigenere.vigenere" href="crypto/cipher/vigenere.html#refinery.units.crypto.cipher.vigenere.vigenere">vigenere</a></li>
<li><a title="refinery.units.crypto.cipher.xtea.xtea" href="crypto/cipher/xtea.html#refinery.units.crypto.cipher.xtea.xtea">xtea</a></li>
<li><a title="refinery.units.crypto.hash.checksums.adler32" href="crypto/hash/checksums.html#refinery.units.crypto.hash.checksums.adler32">adler32</a></li>
<li><a title="refinery.units.crypto.hash.checksums.crc32" href="crypto/hash/checksums.html#refinery.units.crypto.hash.checksums.crc32">crc32</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.blk224" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.blk224">blk224</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.blk256" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.blk256">blk256</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.blk384" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.blk384">blk384</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.blk512" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.blk512">blk512</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.md5" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.md5">md5</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.sha1" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.sha1">sha1</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.sha224" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.sha224">sha224</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.sha256" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.sha256">sha256</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.sha384" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.sha384">sha384</a></li>
<li><a title="refinery.units.crypto.hash.cryptographic.sha512" href="crypto/hash/cryptographic.html#refinery.units.crypto.hash.cryptographic.sha512">sha512</a></li>
<li><a title="refinery.units.crypto.hash.imphash.imphash" href="crypto/hash/imphash.html#refinery.units.crypto.hash.imphash.imphash">imphash</a></li>
<li><a title="refinery.units.crypto.keyderive.CryptDeriveKey.CryptDeriveKey" href="crypto/keyderive/CryptDeriveKey.html#refinery.units.crypto.keyderive.CryptDeriveKey.CryptDeriveKey">CryptDeriveKey</a></li>
<li><a title="refinery.units.crypto.keyderive.DESDerive.DESDerive" href="crypto/keyderive/DESDerive.html#refinery.units.crypto.keyderive.DESDerive.DESDerive">DESDerive</a></li>
<li><a title="refinery.units.crypto.keyderive.PasswordDeriveBytes.PasswordDeriveBytes" href="crypto/keyderive/PasswordDeriveBytes.html#refinery.units.crypto.keyderive.PasswordDeriveBytes.PasswordDeriveBytes">PasswordDeriveBytes</a></li>
<li><a title="refinery.units.crypto.keyderive.hkdf.HKDF" href="crypto/keyderive/hkdf.html#refinery.units.crypto.keyderive.hkdf.HKDF">HKDF</a></li>
<li><a title="refinery.units.crypto.keyderive.kblob.kblob" href="crypto/keyderive/kblob.html#refinery.units.crypto.keyderive.kblob.kblob">kblob</a></li>
<li><a title="refinery.units.crypto.keyderive.pbkdf1.PBKDF1" href="crypto/keyderive/pbkdf1.html#refinery.units.crypto.keyderive.pbkdf1.PBKDF1">PBKDF1</a></li>
<li><a title="refinery.units.crypto.keyderive.pbkdf2.PBKDF2" href="crypto/keyderive/pbkdf2.html#refinery.units.crypto.keyderive.pbkdf2.PBKDF2">PBKDF2</a></li>
<li><a title="refinery.units.crypto.keyderive.unixcrypt.ucrypt" href="crypto/keyderive/unixcrypt.html#refinery.units.crypto.keyderive.unixcrypt.ucrypt">ucrypt</a></li>
<li><a title="refinery.units.encoding.b32.b32" href="encoding/b32.html#refinery.units.encoding.b32.b32">b32</a></li>
<li><a title="refinery.units.encoding.b64.b64" href="encoding/b64.html#refinery.units.encoding.b64.b64">b64</a></li>
<li><a title="refinery.units.encoding.b85.b85" href="encoding/b85.html#refinery.units.encoding.b85.b85">b85</a></li>
<li><a title="refinery.units.encoding.base.base" href="encoding/base.html#refinery.units.encoding.base.base">base</a></li>
<li><a title="refinery.units.encoding.cp1252.cp1252" href="encoding/cp1252.html#refinery.units.encoding.cp1252.cp1252">cp1252</a></li>
<li><a title="refinery.units.encoding.esc.esc" href="encoding/esc.html#refinery.units.encoding.esc.esc">esc</a></li>
<li><a title="refinery.units.encoding.hex.hex" href="encoding/hex.html#refinery.units.encoding.hex.hex">hex</a></li>
<li><a title="refinery.units.encoding.htm.html" href="encoding/htm.html#refinery.units.encoding.htm.html">html</a></li>
<li><a title="refinery.units.encoding.netbios.netbios" href="encoding/netbios.html#refinery.units.encoding.netbios.netbios">netbios</a></li>
<li><a title="refinery.units.encoding.ps1str.ps1str" href="encoding/ps1str.html#refinery.units.encoding.ps1str.ps1str">ps1str</a></li>
<li><a title="refinery.units.encoding.recode.recode" href="encoding/recode.html#refinery.units.encoding.recode.recode">recode</a></li>
<li><a title="refinery.units.encoding.u16.u16" href="encoding/u16.html#refinery.units.encoding.u16.u16">u16</a></li>
<li><a title="refinery.units.encoding.url.url" href="encoding/url.html#refinery.units.encoding.url.url">url</a></li>
<li><a title="refinery.units.encoding.vbe.vbe" href="encoding/vbe.html#refinery.units.encoding.vbe.vbe">vbe</a></li>
<li><a title="refinery.units.formats.deserialize_java.dsjava" href="formats/deserialize_java.html#refinery.units.formats.deserialize_java.dsjava">dsjava</a></li>
<li><a title="refinery.units.formats.deserialize_php.dsphp" href="formats/deserialize_php.html#refinery.units.formats.deserialize_php.dsphp">dsphp</a></li>
<li><a title="refinery.units.formats.elf.elfslice.elfslice" href="formats/elf/elfslice.html#refinery.units.formats.elf.elfslice.elfslice">elfslice</a></li>
<li><a title="refinery.units.formats.email.xtmail" href="formats/email.html#refinery.units.formats.email.xtmail">xtmail</a></li>
<li><a title="refinery.units.formats.httpresponse.httpresponse" href="formats/httpresponse.html#refinery.units.formats.httpresponse.httpresponse">httpresponse</a></li>
<li><a title="refinery.units.formats.office.xlxtr.xlxtr" href="formats/office/xlxtr.html#refinery.units.formats.office.xlxtr.xlxtr">xlxtr</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dncfx.dncfx" href="formats/pe/dotnet/dncfx.html#refinery.units.formats.pe.dotnet.dncfx.dncfx">dncfx</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnds.dnds" href="formats/pe/dotnet/dnds.html#refinery.units.formats.pe.dotnet.dnds.dnds">dnds</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnfields.dnfields" href="formats/pe/dotnet/dnfields.html#refinery.units.formats.pe.dotnet.dnfields.dnfields">dnfields</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnhdr.dnhdr" href="formats/pe/dotnet/dnhdr.html#refinery.units.formats.pe.dotnet.dnhdr.dnhdr">dnhdr</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnmr.dnmr" href="formats/pe/dotnet/dnmr.html#refinery.units.formats.pe.dotnet.dnmr.dnmr">dnmr</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnrc.dnrc" href="formats/pe/dotnet/dnrc.html#refinery.units.formats.pe.dotnet.dnrc.dnrc">dnrc</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnstr.dnstr" href="formats/pe/dotnet/dnstr.html#refinery.units.formats.pe.dotnet.dnstr.dnstr">dnstr</a></li>
<li><a title="refinery.units.formats.pe.pemeta.pemeta" href="formats/pe/pemeta.html#refinery.units.formats.pe.pemeta.pemeta">pemeta</a></li>
<li><a title="refinery.units.formats.pe.peoverlay.peoverlay" href="formats/pe/peoverlay.html#refinery.units.formats.pe.peoverlay.peoverlay">peoverlay</a></li>
<li><a title="refinery.units.formats.pe.perc.perc" href="formats/pe/perc.html#refinery.units.formats.pe.perc.perc">perc</a></li>
<li><a title="refinery.units.formats.pe.pesig.pesig" href="formats/pe/pesig.html#refinery.units.formats.pe.pesig.pesig">pesig</a></li>
<li><a title="refinery.units.formats.pe.peslice.peslice" href="formats/pe/peslice.html#refinery.units.formats.pe.peslice.peslice">peslice</a></li>
<li><a title="refinery.units.formats.pe.pestrip.pestrip" href="formats/pe/pestrip.html#refinery.units.formats.pe.pestrip.pestrip">pestrip</a></li>
<li><a title="refinery.units.formats.pkcs7.pkcs7" href="formats/pkcs7.html#refinery.units.formats.pkcs7.pkcs7">pkcs7</a></li>
<li><a title="refinery.units.formats.winreg.winreg" href="formats/winreg.html#refinery.units.formats.winreg.winreg">winreg</a></li>
<li><a title="refinery.units.formats.zipfile.xtzip" href="formats/zipfile.html#refinery.units.formats.zipfile.xtzip">xtzip</a></li>
<li><a title="refinery.units.meta.chop.chop" href="meta/chop.html#refinery.units.meta.chop.chop">chop</a></li>
<li><a title="refinery.units.meta.couple.couple" href="meta/couple.html#refinery.units.meta.couple.couple">couple</a></li>
<li><a title="refinery.units.meta.dedup.dedup" href="meta/dedup.html#refinery.units.meta.dedup.dedup">dedup</a></li>
<li><a title="refinery.units.meta.emit.emit" href="meta/emit.html#refinery.units.meta.emit.emit">emit</a></li>
<li><a title="refinery.units.meta.fread.fread" href="meta/fread.html#refinery.units.meta.fread.fread">fread</a></li>
<li><a title="refinery.units.meta.mpop.mpop" href="meta/mpop.html#refinery.units.meta.mpop.mpop">mpop</a></li>
<li><a title="refinery.units.meta.mpush.mpush" href="meta/mpush.html#refinery.units.meta.mpush.mpush">mpush</a></li>
<li><a title="refinery.units.meta.mput.mput" href="meta/mput.html#refinery.units.meta.mput.mput">mput</a></li>
<li><a title="refinery.units.meta.nop.nop" href="meta/nop.html#refinery.units.meta.nop.nop">nop</a></li>
<li><a title="refinery.units.meta.pad.pad" href="meta/pad.html#refinery.units.meta.pad.pad">pad</a></li>
<li><a title="refinery.units.meta.pick.pick" href="meta/pick.html#refinery.units.meta.pick.pick">pick</a></li>
<li><a title="refinery.units.meta.scope.scope" href="meta/scope.html#refinery.units.meta.scope.scope">scope</a></li>
<li><a title="refinery.units.meta.sep.sep" href="meta/sep.html#refinery.units.meta.sep.sep">sep</a></li>
<li><a title="refinery.units.meta.sorted.sorted" href="meta/sorted.html#refinery.units.meta.sorted.sorted">sorted</a></li>
<li><a title="refinery.units.misc.autoxor.autoxor" href="misc/autoxor.html#refinery.units.misc.autoxor.autoxor">autoxor</a></li>
<li><a title="refinery.units.misc.binpng.binpng" href="misc/binpng.html#refinery.units.misc.binpng.binpng">binpng</a></li>
<li><a title="refinery.units.misc.datefix.datefix" href="misc/datefix.html#refinery.units.misc.datefix.datefix">datefix</a></li>
<li><a title="refinery.units.obfuscation.ps1.all.deob_ps1" href="obfuscation/ps1/all.html#refinery.units.obfuscation.ps1.all.deob_ps1">deob_ps1</a></li>
<li><a title="refinery.units.obfuscation.ps1.brackets.deob_ps1_brackets" href="obfuscation/ps1/brackets.html#refinery.units.obfuscation.ps1.brackets.deob_ps1_brackets">deob_ps1_brackets</a></li>
<li><a title="refinery.units.obfuscation.ps1.cases.deob_ps1_cases" href="obfuscation/ps1/cases.html#refinery.units.obfuscation.ps1.cases.deob_ps1_cases">deob_ps1_cases</a></li>
<li><a title="refinery.units.obfuscation.ps1.concat.deob_ps1_concat" href="obfuscation/ps1/concat.html#refinery.units.obfuscation.ps1.concat.deob_ps1_concat">deob_ps1_concat</a></li>
<li><a title="refinery.units.obfuscation.ps1.escape.deob_ps1_escape" href="obfuscation/ps1/escape.html#refinery.units.obfuscation.ps1.escape.deob_ps1_escape">deob_ps1_escape</a></li>
<li><a title="refinery.units.obfuscation.ps1.format.deob_ps1_format" href="obfuscation/ps1/format.html#refinery.units.obfuscation.ps1.format.deob_ps1_format">deob_ps1_format</a></li>
<li><a title="refinery.units.obfuscation.ps1.invoke.deob_ps1_invoke" href="obfuscation/ps1/invoke.html#refinery.units.obfuscation.ps1.invoke.deob_ps1_invoke">deob_ps1_invoke</a></li>
<li><a title="refinery.units.obfuscation.ps1.literals.deob_ps1_literals" href="obfuscation/ps1/literals.html#refinery.units.obfuscation.ps1.literals.deob_ps1_literals">deob_ps1_literals</a></li>
<li><a title="refinery.units.obfuscation.ps1.securestring.deob_ps1_secstr" href="obfuscation/ps1/securestring.html#refinery.units.obfuscation.ps1.securestring.deob_ps1_secstr">deob_ps1_secstr</a></li>
<li><a title="refinery.units.obfuscation.ps1.stringreplace.deob_ps1_stringreplace" href="obfuscation/ps1/stringreplace.html#refinery.units.obfuscation.ps1.stringreplace.deob_ps1_stringreplace">deob_ps1_stringreplace</a></li>
<li><a title="refinery.units.obfuscation.ps1.typecast.deob_ps1_typecast" href="obfuscation/ps1/typecast.html#refinery.units.obfuscation.ps1.typecast.deob_ps1_typecast">deob_ps1_typecast</a></li>
<li><a title="refinery.units.obfuscation.vba.arithmetic.deob_vba_arithmetic" href="obfuscation/vba/arithmetic.html#refinery.units.obfuscation.vba.arithmetic.deob_vba_arithmetic">deob_vba_arithmetic</a></li>
<li><a title="refinery.units.obfuscation.vba.comments.deob_vba_comments" href="obfuscation/vba/comments.html#refinery.units.obfuscation.vba.comments.deob_vba_comments">deob_vba_comments</a></li>
<li><a title="refinery.units.obfuscation.vba.constants.deob_vba_constants" href="obfuscation/vba/constants.html#refinery.units.obfuscation.vba.constants.deob_vba_constants">deob_vba_constants</a></li>
<li><a title="refinery.units.obfuscation.vba.dummies.deob_vba_dummy_variables" href="obfuscation/vba/dummies.html#refinery.units.obfuscation.vba.dummies.deob_vba_dummy_variables">deob_vba_dummy_variables</a></li>
<li><a title="refinery.units.obfuscation.vba.vba.deob_vba_chr_literals" href="obfuscation/vba/vba.html#refinery.units.obfuscation.vba.vba.deob_vba_chr_literals">deob_vba_chr_literals</a></li>
<li><a title="refinery.units.pattern.carve.carve" href="pattern/carve.html#refinery.units.pattern.carve.carve">carve</a></li>
<li><a title="refinery.units.pattern.carve_json.carve_json" href="pattern/carve_json.html#refinery.units.pattern.carve_json.carve_json">carve_json</a></li>
<li><a title="refinery.units.pattern.carve_pe.carve_pe" href="pattern/carve_pe.html#refinery.units.pattern.carve_pe.carve_pe">carve_pe</a></li>
<li><a title="refinery.units.pattern.carve_xml.carve_xml" href="pattern/carve_xml.html#refinery.units.pattern.carve_xml.carve_xml">carve_xml</a></li>
<li><a title="refinery.units.pattern.carve_zip.carve_zip" href="pattern/carve_zip.html#refinery.units.pattern.carve_zip.carve_zip">carve_zip</a></li>
<li><a title="refinery.units.pattern.defang.defang" href="pattern/defang.html#refinery.units.pattern.defang.defang">defang</a></li>
<li><a title="refinery.units.pattern.dnsdomain.dnsdomain" href="pattern/dnsdomain.html#refinery.units.pattern.dnsdomain.dnsdomain">dnsdomain</a></li>
<li><a title="refinery.units.pattern.mimewords.mimewords" href="pattern/mimewords.html#refinery.units.pattern.mimewords.mimewords">mimewords</a></li>
<li><a title="refinery.units.pattern.resplit.resplit" href="pattern/resplit.html#refinery.units.pattern.resplit.resplit">resplit</a></li>
<li><a title="refinery.units.pattern.resub.resub" href="pattern/resub.html#refinery.units.pattern.resub.resub">resub</a></li>
<li><a title="refinery.units.pattern.rex.rex" href="pattern/rex.html#refinery.units.pattern.rex.rex">rex</a></li>
<li><a title="refinery.units.pattern.urlguards.urlguards" href="pattern/urlguards.html#refinery.units.pattern.urlguards.urlguards">urlguards</a></li>
<li><a title="refinery.units.pattern.xtp.xtp" href="pattern/xtp.html#refinery.units.pattern.xtp.xtp">xtp</a></li>
<li><a title="refinery.units.shortcuts.carveb64z.carveb64z" href="shortcuts/carveb64z.html#refinery.units.shortcuts.carveb64z.carveb64z">carveb64z</a></li>
<li><a title="refinery.units.sinks.asm.asm" href="sinks/asm.html#refinery.units.sinks.asm.asm">asm</a></li>
<li><a title="refinery.units.sinks.dump.dump" href="sinks/dump.html#refinery.units.sinks.dump.dump">dump</a></li>
<li><a title="refinery.units.sinks.hexview.hexview" href="sinks/hexview.html#refinery.units.sinks.hexview.hexview">hexview</a></li>
<li><a title="refinery.units.sinks.peek.peek" href="sinks/peek.html#refinery.units.sinks.peek.peek">peek</a></li>
<li><a title="refinery.units.sinks.ppjson.ppjson" href="sinks/ppjson.html#refinery.units.sinks.ppjson.ppjson">ppjson</a></li>
<li><a title="refinery.units.sinks.ppxml.ppxml" href="sinks/ppxml.html#refinery.units.sinks.ppxml.ppxml">ppxml</a></li>
<li><a title="refinery.units.strings.cca.cca" href="strings/cca.html#refinery.units.strings.cca.cca">cca</a></li>
<li><a title="refinery.units.strings.ccp.ccp" href="strings/ccp.html#refinery.units.strings.ccp.ccp">ccp</a></li>
<li><a title="refinery.units.strings.cfmt.cfmt" href="strings/cfmt.html#refinery.units.strings.cfmt.cfmt">cfmt</a></li>
<li><a title="refinery.units.strings.clower.clower" href="strings/clower.html#refinery.units.strings.clower.clower">clower</a></li>
<li><a title="refinery.units.strings.cupper.cupper" href="strings/cupper.html#refinery.units.strings.cupper.cupper">cupper</a></li>
<li><a title="refinery.units.strings.rep.rep" href="strings/rep.html#refinery.units.strings.rep.rep">rep</a></li>
<li><a title="refinery.units.strings.repl.repl" href="strings/repl.html#refinery.units.strings.repl.repl">repl</a></li>
<li><a title="refinery.units.strings.snip.snip" href="strings/snip.html#refinery.units.strings.snip.snip">snip</a></li>
<li><a title="refinery.units.strings.stretch.stretch" href="strings/stretch.html#refinery.units.strings.stretch.stretch">stretch</a></li>
<li><a title="refinery.units.strings.termfit.termfit" href="strings/termfit.html#refinery.units.strings.termfit.termfit">termfit</a></li>
<li><a title="refinery.units.strings.trim.trim" href="strings/trim.html#refinery.units.strings.trim.trim">trim</a></li>
</ul>
</dd>
<dt id="refinery.units.Argument"><code class="flex name class">
<span>class <span class="ident">Argument</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This class implements an abstract argument to a Python function, including positional
and keyword arguments. Passing an <code><a title="refinery.units.Argument" href="#refinery.units.Argument">Argument</a></code> to a Python function can be done via the
matrix multiplication operator: The syntax <code>function @ Argument(a, b, kwd=c)</code> is
equivalent to the call <code>function(a, b, kwd=c)</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L88-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Argument:
    &#34;&#34;&#34;
    This class implements an abstract argument to a Python function, including positional
    and keyword arguments. Passing an `Argument` to a Python function can be done via the
    matrix multiplication operator: The syntax `function @ Argument(a, b, kwd=c)` is
    equivalent to the call `function(a, b, kwd=c)`.
    &#34;&#34;&#34;
    __slots__ = &#39;args&#39;, &#39;kwargs&#39;

    def __init__(self, *args, **kwargs):
        self.args = list(args)
        self.kwargs = kwargs

    def __rmatmul__(self, method):
        return method(*self.args, **self.kwargs)

    def __repr__(self):
        def rep(v):
            r = repr(v)
            if r.startswith(&#39;&lt;&#39;):
                try:
                    return v.__name__
                except AttributeError:
                    pass
                try:
                    return v.__class__.__name__
                except AttributeError:
                    pass
            return r
        arglist = [repr(a) for a in self.args]
        arglist.extend(F&#39;{key!s}={rep(value)}&#39; for key, value in self.kwargs.items())
        return &#39;, &#39;.join(arglist)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.arg" href="#refinery.units.arg">arg</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.Argument.args"><code class="name">var <span class="ident">args</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="refinery.units.Argument.kwargs"><code class="name">var <span class="ident">kwargs</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.arg"><code class="flex name class">
<span>class <span class="ident">arg</span></span>
<span>(</span><span>*args, action=refinery.units.arg.omit, choices=refinery.units.arg.omit, const=refinery.units.arg.omit, default=refinery.units.arg.omit, dest=refinery.units.arg.omit, help=refinery.units.arg.omit, metavar=refinery.units.arg.omit, nargs=refinery.units.arg.omit, required=refinery.units.arg.omit, type=refinery.units.arg.omit, group=None, guess=False)</span>
</code></dt>
<dd>
<section class="desc"><p>This child class of <code><a title="refinery.units.Argument" href="#refinery.units.Argument">Argument</a></code> is specifically an argument for the
<code>add_argument</code> method of an <code>ArgumentParser</code> from the <code>argparse</code> module. It can also
be used as a decorator for the constructor of a refinery unit to better control
the argument parser of that unit's command line interface. Example:</p>
<pre><code>class prefixer(Unit):
    @arg('prefix', help='this data will be prepended to the input.')
    def __init__(self, prefix): pass

    def process(self, data):
        return self.args.prefix + data
</code></pre>
<p>Note that when the init of a unit has a return annotation that is a base class of
itself, then all its parameters will automatically be forwarded to that base class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L122-L393" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class arg(Argument):
    &#34;&#34;&#34;
    This child class of `refinery.units.Argument` is specifically an argument for the
    `add_argument` method of an `ArgumentParser` from the `argparse` module. It can also
    be used as a decorator for the constructor of a refinery unit to better control
    the argument parser of that unit&#39;s command line interface. Example:
    ```
    class prefixer(Unit):
        @arg(&#39;prefix&#39;, help=&#39;this data will be prepended to the input.&#39;)
        def __init__(self, prefix): pass

        def process(self, data):
            return self.args.prefix + data
    ```
    Note that when the init of a unit has a return annotation that is a base class of
    itself, then all its parameters will automatically be forwarded to that base class.
    &#34;&#34;&#34;

    class delete: pass
    class omit: pass

    def __init__(
        self, *args: str,
            action   : Union[omit, str]           = omit, # noqa
            choices  : Union[omit, Iterable[Any]] = omit, # noqa
            const    : Union[omit, Any]           = omit, # noqa
            default  : Union[omit, Any]           = omit, # noqa
            dest     : Union[omit, str]           = omit, # noqa
            help     : Union[omit, str]           = omit, # noqa
            metavar  : Union[omit, str]           = omit, # noqa
            nargs    : Union[omit, int, str]      = omit, # noqa
            required : Union[omit, bool]          = omit, # noqa
            type     : Union[omit, type]          = omit, # noqa
            group    : Optional[str]              = None, # noqa
            guess    : bool                       = False # noqa
    ) -&gt; None:
        kwargs = dict(action=action, choices=choices, const=const, default=default, dest=dest,
            help=help, metavar=metavar, nargs=nargs, required=required, type=type)
        kwargs = {key: value for key, value in kwargs.items() if value is not arg.omit}
        self.group = group
        self.guess = guess
        super().__init__(*args, **kwargs)

    def update_help(self):
        if &#39;help&#39; not in self.kwargs:
            return
        formatting = {}
        choices = self.kwargs.get(&#39;choices&#39;, None)
        if choices is not None:
            formatting.update(choices=&#39;, &#39;.join(self.kwargs[&#39;choices&#39;]))
        default = self.kwargs.get(&#39;default&#39;, None)
        if default is not None:
            try:
                formatting.update(default=F&#39;H:{default.hex()}&#39;)
            except AttributeError:
                formatting.update(default=str(default))
        try:
            self.kwargs[&#39;help&#39;] = self.kwargs[&#39;help&#39;].format(**formatting)
        except Exception:
            pass

    def __rmatmul__(self, method):
        self.update_help()
        return super().__rmatmul__(method)

    @staticmethod
    def switch(
        *args: str, off=False,
        help : Union[omit, str] = omit,
        dest : Union[omit, str] = omit,
        group: Optional[str] = None,
    ) -&gt; Argument:
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that change a boolean value from True to False or
        vice versa. By default, a switch will have a False default and change it to True when specified.
        &#34;&#34;&#34;
        return arg(*args, group=group, help=help, dest=dest, action=&#39;store_false&#39; if off else &#39;store_true&#39;)

    @staticmethod
    def number(
        *args: str,
        bound: Union[omit, Tuple[int, int]] = omit,
        help : Union[omit, str] = omit,
        dest : Union[omit, str] = omit,
        metavar : Optional[str] = None,
        group: Optional[str] = None,
    ) -&gt; Argument:
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a number.
        &#34;&#34;&#34;
        nt = number
        if bound is not arg.omit:
            lower, upper = bound
            nt = nt[lower:upper]
        return arg(*args, group=group, help=help, dest=dest, type=nt, metavar=metavar or &#39;N&#39;)

    @staticmethod
    def option(
        *args: str, choices: Enum,
        help : Union[omit, str] = omit,
        dest : Union[omit, str] = omit,
        metavar: Optional[str] = None,
        group: Optional[str] = None,
    ) -&gt; Argument:
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on an enumeration.
        &#34;&#34;&#34;
        cnames = [c.name for c in choices]
        metavar = metavar or choices.__name__
        return arg(*args, group=group, help=help, metavar=metavar, dest=dest, choices=cnames, type=str)

    @staticmethod
    def choice(
        *args: str, choices : List[str],
        help    : Union[omit, str] = omit,
        metavar : Union[omit, str] = omit,
        dest    : Union[omit, str] = omit,
        nargs   : Union[omit, int, str] = omit,
        group   : Optional[str] = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on a list of strings.
        &#34;&#34;&#34;
        return arg(*args, group=group, type=str, metavar=metavar, nargs=nargs,
            dest=dest, help=help, choices=choices)

    @property
    def positional(self) -&gt; bool:
        return any(a[0] != &#39;-&#39; for a in self.args)

    @property
    def destination(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the variable where the contents of this parsed argument will be stored.
        &#34;&#34;&#34;
        for a in self.args:
            if a[0] != &#39;-&#39;:
                return a
        try:
            return self.kwargs[&#39;dest&#39;]
        except KeyError:
            for a in self.args:
                if a.startswith(&#39;--&#39;):
                    dest = a.lstrip(&#39;-&#39;).replace(&#39;-&#39;, &#39;_&#39;)
                    if dest.isidentifier():
                        return dest
            raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)

    @classmethod
    def infer(cls, pt: inspect.Parameter) -&gt; Argument:
        &#34;&#34;&#34;
        This class method can be used to infer the argparse argument for a Python function
        parameter. This guess is based on the annotation, name, and default value.
        &#34;&#34;&#34;

        def needs_type(item):
            return item.get(&#39;action&#39;, &#39;store&#39;) == &#39;store&#39;

        def get_argp_type(annotation_type):
            if issubclass(annotation_type, (bytes, bytearray, memoryview)):
                return multibin
            if issubclass(annotation_type, int):
                return number
            if issubclass(annotation_type, slice):
                return sliceobj
            return annotation_type

        name = pt.name.replace(&#39;_&#39;, &#39;-&#39;)
        default = pt.default
        guessed_pos_args = []
        guessed_kwd_args = dict(dest=pt.name, guess=True)
        annotation = pt.annotation

        if isinstance(annotation, str):
            try: annotation = eval(annotation)
            except Exception: pass

        if annotation is not pt.empty:
            if isinstance(annotation, Argument):
                if annotation.kwargs.get(&#39;dest&#39;, pt.name) != pt.name:
                    raise ValueError(
                        F&#39;Incompatible argument destination specified; parameter {pt.name} &#39;
                        F&#39;was annotated with {annotation!r}.&#39;)
                guessed_pos_args = annotation.args
                guessed_kwd_args.update(annotation.kwargs)
                guessed_kwd_args[&#39;guess&#39;] = False
                guessed_kwd_args[&#39;group&#39;] = annotation.group
            elif isinstance(annotation, type):
                if not issubclass(annotation, bool) and needs_type(guessed_kwd_args):
                    guessed_kwd_args.update(type=get_argp_type(annotation))
                elif not isinstance(default, bool):
                    raise ValueError(&#39;Default value for boolean arguments must be provided.&#39;)

        if not guessed_pos_args:
            guessed_pos_args = guessed_pos_args or [F&#39;--{name}&#39; if pt.kind is pt.KEYWORD_ONLY else name]

        if pt.kind is pt.VAR_POSITIONAL:
            oldnargs = guessed_kwd_args.setdefault(&#39;nargs&#39;, ZERO_OR_MORE)
            if oldnargs not in (ONE_OR_MORE, ZERO_OR_MORE, REMAINDER):
                raise ValueError(F&#39;Variadic positional arguments has nargs set to {oldnargs!r}&#39;)
            return cls(*guessed_pos_args, **guessed_kwd_args)

        if default is not pt.empty:
            if isinstance(default, (list, tuple)):
                guessed_kwd_args.setdefault(&#39;nargs&#39;, ZERO_OR_MORE)
                if not pt.default:
                    default = pt.empty
                else:
                    guessed_kwd_args.setdefault(&#39;default&#39;, pt.default)
                    default = default[0]
            else:
                guessed_kwd_args.setdefault(&#39;default&#39;, default)
                if pt.kind is pt.POSITIONAL_ONLY:
                    guessed_kwd_args.setdefault(&#39;nargs&#39;, OPTIONAL)

        if default is not pt.empty:
            if isinstance(default, bool):
                guessed_kwd_args[&#39;action&#39;] = &#39;store_false&#39; if default else &#39;store_true&#39;
            elif needs_type(guessed_kwd_args) and &#39;type&#39; not in guessed_kwd_args:
                guessed_kwd_args[&#39;type&#39;] = get_argp_type(type(default))

        return cls(*guessed_pos_args, **guessed_kwd_args)

    def merge_args(self, them: Argument) -&gt; None:
        def iterboth():
            yield from them.args
            yield from self.args
        if not self.args:
            self.args = list(them.args)
            return
        sflag = None
        lflag = None
        for a in iterboth():
            if a[:2] == &#39;--&#39;: lflag = lflag or a
            elif a[0] == &#39;-&#39;: sflag = sflag or a
        self.args = []
        if sflag: self.args.append(sflag)
        if lflag: self.args.append(lflag)
        if not self.args:
            self.args = list(them.args)

    def merge_all(self, them: Argument) -&gt; None:
        for key, value in them.kwargs.items():
            if value is arg.delete:
                self.kwargs.pop(key, None)
                continue
            self.kwargs[key] = value
        self.merge_args(them)
        self.guess = self.guess and them.guess
        self.group = self.group or them.group

    def __copy__(self) -&gt; Argument:
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.kwargs = dict(self.kwargs)
        clone.args = list(self.args)
        clone.group = self.group
        clone.guess = self.guess
        return clone

    def __repr__(self) -&gt; str:
        return F&#39;arg({super().__repr__()})&#39;

    def __call__(self, init: Callable) -&gt; Callable:
        parameters = inspect.signature(init).parameters
        try:
            inferred = arg.infer(parameters[self.destination])
            inferred.merge_all(self)
            init.__annotations__[self.destination] = inferred
        except KeyError:
            raise ValueError(F&#39;Unable to decorate because no parameter with name {self.destination} exists.&#39;)
        return init</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Argument" href="#refinery.units.Argument">Argument</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.arg.delete"><code class="name">var <span class="ident">delete</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.arg.omit"><code class="name">var <span class="ident">omit</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.arg.switch"><code class="name flex">
<span>def <span class="ident">switch</span></span>(<span>*args, off=False, help=refinery.units.arg.omit, dest=refinery.units.arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A convenience method to add argparse arguments that change a boolean value from True to False or
vice versa. By default, a switch will have a False default and change it to True when specified.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L187-L198" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def switch(
    *args: str, off=False,
    help : Union[omit, str] = omit,
    dest : Union[omit, str] = omit,
    group: Optional[str] = None,
) -&gt; Argument:
    &#34;&#34;&#34;
    A convenience method to add argparse arguments that change a boolean value from True to False or
    vice versa. By default, a switch will have a False default and change it to True when specified.
    &#34;&#34;&#34;
    return arg(*args, group=group, help=help, dest=dest, action=&#39;store_false&#39; if off else &#39;store_true&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.units.arg.number"><code class="name flex">
<span>def <span class="ident">number</span></span>(<span>*args, bound=refinery.units.arg.omit, help=refinery.units.arg.omit, dest=refinery.units.arg.omit, metavar=None, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain a number.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L200-L216" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def number(
    *args: str,
    bound: Union[omit, Tuple[int, int]] = omit,
    help : Union[omit, str] = omit,
    dest : Union[omit, str] = omit,
    metavar : Optional[str] = None,
    group: Optional[str] = None,
) -&gt; Argument:
    &#34;&#34;&#34;
    Used to add argparse arguments that contain a number.
    &#34;&#34;&#34;
    nt = number
    if bound is not arg.omit:
        lower, upper = bound
        nt = nt[lower:upper]
    return arg(*args, group=group, help=help, dest=dest, type=nt, metavar=metavar or &#39;N&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.units.arg.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>*args, choices, help=refinery.units.arg.omit, dest=refinery.units.arg.omit, metavar=None, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments with a fixed set of options, based on an enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L218-L231" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def option(
    *args: str, choices: Enum,
    help : Union[omit, str] = omit,
    dest : Union[omit, str] = omit,
    metavar: Optional[str] = None,
    group: Optional[str] = None,
) -&gt; Argument:
    &#34;&#34;&#34;
    Used to add argparse arguments with a fixed set of options, based on an enumeration.
    &#34;&#34;&#34;
    cnames = [c.name for c in choices]
    metavar = metavar or choices.__name__
    return arg(*args, group=group, help=help, metavar=metavar, dest=dest, choices=cnames, type=str)</code></pre>
</details>
</dd>
<dt id="refinery.units.arg.choice"><code class="name flex">
<span>def <span class="ident">choice</span></span>(<span>*args, choices, help=refinery.units.arg.omit, metavar=refinery.units.arg.omit, dest=refinery.units.arg.omit, nargs=refinery.units.arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments with a fixed set of options, based on a list of strings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L233-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def choice(
    *args: str, choices : List[str],
    help    : Union[omit, str] = omit,
    metavar : Union[omit, str] = omit,
    dest    : Union[omit, str] = omit,
    nargs   : Union[omit, int, str] = omit,
    group   : Optional[str] = None,
):
    &#34;&#34;&#34;
    Used to add argparse arguments with a fixed set of options, based on a list of strings.
    &#34;&#34;&#34;
    return arg(*args, group=group, type=str, metavar=metavar, nargs=nargs,
        dest=dest, help=help, choices=choices)</code></pre>
</details>
</dd>
<dt id="refinery.units.arg.infer"><code class="name flex">
<span>def <span class="ident">infer</span></span>(<span>pt)</span>
</code></dt>
<dd>
<section class="desc"><p>This class method can be used to infer the argparse argument for a Python function
parameter. This guess is based on the annotation, name, and default value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L270-L343" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def infer(cls, pt: inspect.Parameter) -&gt; Argument:
    &#34;&#34;&#34;
    This class method can be used to infer the argparse argument for a Python function
    parameter. This guess is based on the annotation, name, and default value.
    &#34;&#34;&#34;

    def needs_type(item):
        return item.get(&#39;action&#39;, &#39;store&#39;) == &#39;store&#39;

    def get_argp_type(annotation_type):
        if issubclass(annotation_type, (bytes, bytearray, memoryview)):
            return multibin
        if issubclass(annotation_type, int):
            return number
        if issubclass(annotation_type, slice):
            return sliceobj
        return annotation_type

    name = pt.name.replace(&#39;_&#39;, &#39;-&#39;)
    default = pt.default
    guessed_pos_args = []
    guessed_kwd_args = dict(dest=pt.name, guess=True)
    annotation = pt.annotation

    if isinstance(annotation, str):
        try: annotation = eval(annotation)
        except Exception: pass

    if annotation is not pt.empty:
        if isinstance(annotation, Argument):
            if annotation.kwargs.get(&#39;dest&#39;, pt.name) != pt.name:
                raise ValueError(
                    F&#39;Incompatible argument destination specified; parameter {pt.name} &#39;
                    F&#39;was annotated with {annotation!r}.&#39;)
            guessed_pos_args = annotation.args
            guessed_kwd_args.update(annotation.kwargs)
            guessed_kwd_args[&#39;guess&#39;] = False
            guessed_kwd_args[&#39;group&#39;] = annotation.group
        elif isinstance(annotation, type):
            if not issubclass(annotation, bool) and needs_type(guessed_kwd_args):
                guessed_kwd_args.update(type=get_argp_type(annotation))
            elif not isinstance(default, bool):
                raise ValueError(&#39;Default value for boolean arguments must be provided.&#39;)

    if not guessed_pos_args:
        guessed_pos_args = guessed_pos_args or [F&#39;--{name}&#39; if pt.kind is pt.KEYWORD_ONLY else name]

    if pt.kind is pt.VAR_POSITIONAL:
        oldnargs = guessed_kwd_args.setdefault(&#39;nargs&#39;, ZERO_OR_MORE)
        if oldnargs not in (ONE_OR_MORE, ZERO_OR_MORE, REMAINDER):
            raise ValueError(F&#39;Variadic positional arguments has nargs set to {oldnargs!r}&#39;)
        return cls(*guessed_pos_args, **guessed_kwd_args)

    if default is not pt.empty:
        if isinstance(default, (list, tuple)):
            guessed_kwd_args.setdefault(&#39;nargs&#39;, ZERO_OR_MORE)
            if not pt.default:
                default = pt.empty
            else:
                guessed_kwd_args.setdefault(&#39;default&#39;, pt.default)
                default = default[0]
        else:
            guessed_kwd_args.setdefault(&#39;default&#39;, default)
            if pt.kind is pt.POSITIONAL_ONLY:
                guessed_kwd_args.setdefault(&#39;nargs&#39;, OPTIONAL)

    if default is not pt.empty:
        if isinstance(default, bool):
            guessed_kwd_args[&#39;action&#39;] = &#39;store_false&#39; if default else &#39;store_true&#39;
        elif needs_type(guessed_kwd_args) and &#39;type&#39; not in guessed_kwd_args:
            guessed_kwd_args[&#39;type&#39;] = get_argp_type(type(default))

    return cls(*guessed_pos_args, **guessed_kwd_args)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.arg.positional"><code class="name">var <span class="ident">positional</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L248-L250" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def positional(self) -&gt; bool:
    return any(a[0] != &#39;-&#39; for a in self.args)</code></pre>
</details>
</dd>
<dt id="refinery.units.arg.destination"><code class="name">var <span class="ident">destination</span></code></dt>
<dd>
<section class="desc"><p>The name of the variable where the contents of this parsed argument will be stored.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L252-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def destination(self) -&gt; str:
    &#34;&#34;&#34;
    The name of the variable where the contents of this parsed argument will be stored.
    &#34;&#34;&#34;
    for a in self.args:
        if a[0] != &#39;-&#39;:
            return a
    try:
        return self.kwargs[&#39;dest&#39;]
    except KeyError:
        for a in self.args:
            if a.startswith(&#39;--&#39;):
                dest = a.lstrip(&#39;-&#39;).replace(&#39;-&#39;, &#39;_&#39;)
                if dest.isidentifier():
                    return dest
        raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.arg.update_help"><code class="name flex">
<span>def <span class="ident">update_help</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L165-L181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update_help(self):
    if &#39;help&#39; not in self.kwargs:
        return
    formatting = {}
    choices = self.kwargs.get(&#39;choices&#39;, None)
    if choices is not None:
        formatting.update(choices=&#39;, &#39;.join(self.kwargs[&#39;choices&#39;]))
    default = self.kwargs.get(&#39;default&#39;, None)
    if default is not None:
        try:
            formatting.update(default=F&#39;H:{default.hex()}&#39;)
        except AttributeError:
            formatting.update(default=str(default))
    try:
        self.kwargs[&#39;help&#39;] = self.kwargs[&#39;help&#39;].format(**formatting)
    except Exception:
        pass</code></pre>
</details>
</dd>
<dt id="refinery.units.arg.merge_args"><code class="name flex">
<span>def <span class="ident">merge_args</span></span>(<span>self, them)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L345-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def merge_args(self, them: Argument) -&gt; None:
    def iterboth():
        yield from them.args
        yield from self.args
    if not self.args:
        self.args = list(them.args)
        return
    sflag = None
    lflag = None
    for a in iterboth():
        if a[:2] == &#39;--&#39;: lflag = lflag or a
        elif a[0] == &#39;-&#39;: sflag = sflag or a
    self.args = []
    if sflag: self.args.append(sflag)
    if lflag: self.args.append(lflag)
    if not self.args:
        self.args = list(them.args)</code></pre>
</details>
</dd>
<dt id="refinery.units.arg.merge_all"><code class="name flex">
<span>def <span class="ident">merge_all</span></span>(<span>self, them)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L363-L371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def merge_all(self, them: Argument) -&gt; None:
    for key, value in them.kwargs.items():
        if value is arg.delete:
            self.kwargs.pop(key, None)
            continue
        self.kwargs[key] = value
    self.merge_args(them)
    self.guess = self.guess and them.guess
    self.group = self.group or them.group</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Argument" href="#refinery.units.Argument">Argument</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Argument.args" href="#refinery.units.Argument.args">args</a></code></li>
<li><code><a title="refinery.units.Argument.kwargs" href="#refinery.units.Argument.kwargs">kwargs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.ArgumentSpecification"><code class="flex name class">
<span>class <span class="ident">ArgumentSpecification</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>A container object that stores <code><a title="refinery.units.arg" href="#refinery.units.arg">arg</a></code> specifications.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L396-L409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ArgumentSpecification(OrderedDict):
    &#34;&#34;&#34;
    A container object that stores `refinery.units.arg` specifications.
    &#34;&#34;&#34;

    def merge(self, argument: arg):
        &#34;&#34;&#34;
        Insert or update the specification with the given argument.
        &#34;&#34;&#34;
        dest = argument.destination
        if dest in self:
            self[dest].merge_all(argument)
            return
        self[dest] = argument</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.OrderedDict</li>
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.ArgumentSpecification.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, argument)</span>
</code></dt>
<dd>
<section class="desc"><p>Insert or update the specification with the given argument.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L401-L409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def merge(self, argument: arg):
    &#34;&#34;&#34;
    Insert or update the specification with the given argument.
    &#34;&#34;&#34;
    dest = argument.destination
    if dest in self:
        self[dest].merge_all(argument)
        return
    self[dest] = argument</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.Executable"><code class="flex name class">
<span>class <span class="ident">Executable</span></span>
<span>(</span><span>name, bases, nmspc, abstract=False)</span>
</code></dt>
<dd>
<section class="desc"><p>This is the metaclass for refinery units. A class which is of this type is
required to implement a method <code>run()</code>. If the class is created in the
currently executing module, then an instance of the class is automatically
created after it is defined and its <code>run()</code> method is invoked.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L412-L596" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Executable(type):
    &#34;&#34;&#34;
    This is the metaclass for refinery units. A class which is of this type is
    required to implement a method `run()`. If the class is created in the
    currently executing module, then an instance of the class is automatically
    created after it is defined and its `run()` method is invoked.
    &#34;&#34;&#34;

    Entry = None
    &#34;&#34;&#34;
    This variable stores the executable entry point. If more than one entry point
    are present, only the first one is executed and an error message is generated
    for the other ones.
    &#34;&#34;&#34;

    def _infer_argspec(cls, parameters, args: Optional[ArgumentSpecification] = None):

        args = ArgumentSpecification() if args is None else args
        temp = ArgumentSpecification()

        exposed = [pt.name for pt in skipfirst(parameters.values()) if pt.kind != pt.VAR_KEYWORD]
        # The arguments are added in reverse order to the argument parser later.
        # This is done to have a more intuitive use of decorator based argument configuration.
        exposed.reverse()

        for name in exposed:
            try:
                argument = arg.infer(parameters[name])
            except KeyError:
                continue
            if argument.guess:
                temp.merge(argument)
            else:
                args.merge(argument)

        for guess in temp.values():
            known = args.get(guess.destination, None)
            if known is None:
                args.merge(guess)
                continue
            if not known.positional:
                known.merge_args(guess)
            for k, v in guess.kwargs.items():
                if k == &#39;default&#39;:
                    known.kwargs[k] = v
                else:
                    known.kwargs.setdefault(k, v)

        for name in exposed:
            args.move_to_end(name)

        for known in args.values():
            if known.positional:
                known.kwargs.pop(&#39;dest&#39;, None)
                if &#39;default&#39; in known.kwargs:
                    known.kwargs.setdefault(&#39;nargs&#39;, OPTIONAL)
            elif not any(a.startswith(&#39;--&#39;) for a in known.args):
                flagname = known.destination.replace(&#39;_&#39;, &#39;-&#39;)
                known.args.append(F&#39;--{flagname}&#39;)
            action = known.kwargs.get(&#39;action&#39;, &#39;store&#39;)
            if action.startswith(&#39;store_&#39;):
                known.kwargs.pop(&#39;default&#39;, None)
                continue
            if action == &#39;store&#39;:
                known.kwargs.setdefault(&#39;type&#39;, multibin)
        return args

    def __new__(mcs, name, bases, nmspc, abstract=False):
        def normalize(operation: Callable[[Any, ByteString], Any]) -&gt; Callable[[ByteString], Any]:
            def chunkify(item):
                if isinstance(item, Chunk):
                    return item
                if isinstance(item, dict):
                    return Chunk(item.pop(&#39;data&#39;, None), meta=item)
                return Chunk(item)

            @wraps(operation)
            def wrapped(self, data: ByteString) -&gt; Union[Optional[ByteString], Iterable[ByteString]]:
                if -self.args:
                    if not isinstance(data, bytearray):
                        data = bytearray(data)
                    self.args @= data
                else:
                    try:
                        dt = next(iter(operation.__annotations__.values()))
                        if dt in (bytes, bytearray, memoryview) and not isinstance(data, dt):
                            data = dt(data)
                    except StopIteration:
                        pass
                if wrapped.chunked:
                    return (chunkify(r) for r in operation(self, data))
                return chunkify(operation(self, data))
            wrapped.chunked = inspect.isgeneratorfunction(operation)
            return wrapped

        nmspc.setdefault(&#39;__doc__&#39;, &#39;&#39;)

        for op in (&#39;process&#39;, &#39;reverse&#39;):
            if op in nmspc:
                nmspc[op] = normalize(nmspc[op])

        if not abstract and Entry not in bases:
            bases = bases + (Entry,)

        return super(Executable, mcs).__new__(mcs, name, bases, nmspc)

    def __init__(cls, name, bases, nmspc, abstract=False):
        super(Executable, cls).__init__(name, bases, nmspc)
        parameters = inspect.signature(cls.__init__).parameters
        cls.argspec = ArgumentSpecification()

        if bases:
            parent = bases[0]
            for key, value in parent.argspec.items():
                if not value.guess and key in parameters:
                    cls.argspec[key] = value.__copy__()
            cls._infer_argspec(parameters, cls.argspec)

        if cls.__init__.__code__.co_code == (lambda: None).__code__.co_code:
            base = bases[0]
            head = []
            defs = {}
            tail = None

            for p in skipfirst(parameters.values()):
                if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD):
                    head.append(p.name)
                if p.kind in (p.KEYWORD_ONLY, p.POSITIONAL_OR_KEYWORD) and p.default is not p.empty:
                    defs[p.name] = p.default
                if p.kind is p.VAR_POSITIONAL:
                    tail = p.name

            @wraps(cls.__init__)
            def cls__init__(self, *args, **kw):
                for name, arg in zip(head, args):
                    kw[name] = arg
                if tail:
                    k = min(len(args), len(head))
                    kw[tail] = args[k:]
                for key in defs:
                    if key not in kw:
                        kw[key] = defs[key]
                base.__init__(self, **kw)

            cls.__init__ = cls__init__

        if not abstract and sys.modules[cls.__module__].__name__ == &#39;__main__&#39;:
            if Executable.Entry:
                cls._output(
                    F&#39;not executing this unit because the following unit was &#39;
                    F&#39;already executed: {Executable.Entry}&#39;
                )
            else:
                Executable.Entry = cls.name
                cls.run()

    def __getitem__(cls, other):
        return cls().__getitem__(other)

    def __or__(cls, other):
        return cls().__or__(other)

    def __ror__(cls, other):
        return cls().__ror__(other)

    @property
    def is_reversible(cls) -&gt; bool:
        &#34;&#34;&#34;
        This property is `True` if and only if the unit has a member function
        named `reverse`. By convention, this member function implements the
        inverse of `refinery.units.Unit.process`.
        &#34;&#34;&#34;
        return hasattr(cls, &#39;reverse&#39;)

    @property
    def codec(cls) -&gt; str:
        &#34;&#34;&#34;
        The default codec for encoding textual information between units.
        The value of this property is hardcoded to `UTF8`.
        &#34;&#34;&#34;
        return &#39;UTF8&#39;

    @property
    def name(cls) -&gt; str:
        return cls.__name__.replace(&#39;_&#39;, &#39;-&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.crypto.cipher.CipherExecutable" href="crypto/cipher/index.html#refinery.units.crypto.cipher.CipherExecutable">CipherExecutable</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.Executable.Entry"><code class="name">var <span class="ident">Entry</span></code></dt>
<dd>
<section class="desc"><p>This variable stores the executable entry point. If more than one entry point
are present, only the first one is executed and an error message is generated
for the other ones.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.Executable.is_reversible"><code class="name">var <span class="ident">is_reversible</span></code></dt>
<dd>
<section class="desc"><p>This property is <code>True</code> if and only if the unit has a member function
named <code>reverse</code>. By convention, this member function implements the
inverse of <code><a title="refinery.units.Unit.process" href="#refinery.units.Unit.process">Unit.process()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L577-L584" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_reversible(cls) -&gt; bool:
    &#34;&#34;&#34;
    This property is `True` if and only if the unit has a member function
    named `reverse`. By convention, this member function implements the
    inverse of `refinery.units.Unit.process`.
    &#34;&#34;&#34;
    return hasattr(cls, &#39;reverse&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.units.Executable.codec"><code class="name">var <span class="ident">codec</span></code></dt>
<dd>
<section class="desc"><p>The default codec for encoding textual information between units.
The value of this property is hardcoded to <code>UTF8</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L586-L592" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def codec(cls) -&gt; str:
    &#34;&#34;&#34;
    The default codec for encoding textual information between units.
    The value of this property is hardcoded to `UTF8`.
    &#34;&#34;&#34;
    return &#39;UTF8&#39;</code></pre>
</details>
</dd>
<dt id="refinery.units.Executable.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L594-L596" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def name(cls) -&gt; str:
    return cls.__name__.replace(&#39;_&#39;, &#39;-&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.LogLevel"><code class="flex name class">
<span>class <span class="ident">LogLevel</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration representing the current log level:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L599-L624" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LogLevel(IntEnum):
    &#34;&#34;&#34;
    An enumeration representing the current log level:
    &#34;&#34;&#34;
    DETACHED = -1
    &#34;&#34;&#34;
    This unit is not attached to a terminal but has been instantiated in
    code. This means that the only way to communicate problems is to throw
    an exception.
    &#34;&#34;&#34;
    NONE = 0
    &#34;&#34;&#34;
    Do not log anything.
    &#34;&#34;&#34;
    WARN = 1
    &#34;&#34;&#34;
    Default log level: Log warnings.
    &#34;&#34;&#34;
    INFO = 2
    &#34;&#34;&#34;
    Increased logging.
    &#34;&#34;&#34;
    DEBUG = 3
    &#34;&#34;&#34;
    Maximum logging.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.LogLevel.DETACHED"><code class="name">var <span class="ident">DETACHED</span></code></dt>
<dd>
<section class="desc"><p>This unit is not attached to a terminal but has been instantiated in
code. This means that the only way to communicate problems is to throw
an exception.</p></section>
</dd>
<dt id="refinery.units.LogLevel.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<section class="desc"><p>Do not log anything.</p></section>
</dd>
<dt id="refinery.units.LogLevel.WARN"><code class="name">var <span class="ident">WARN</span></code></dt>
<dd>
<section class="desc"><p>Default log level: Log warnings.</p></section>
</dd>
<dt id="refinery.units.LogLevel.INFO"><code class="name">var <span class="ident">INFO</span></code></dt>
<dd>
<section class="desc"><p>Increased logging.</p></section>
</dd>
<dt id="refinery.units.LogLevel.DEBUG"><code class="name">var <span class="ident">DEBUG</span></code></dt>
<dd>
<section class="desc"><p>Maximum logging.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.DelayedArgumentProxy"><code class="flex name class">
<span>class <span class="ident">DelayedArgumentProxy</span></span>
<span>(</span><span>argv, argo)</span>
</code></dt>
<dd>
<section class="desc"><p>This class implements a proxy for the <code>args</code> member variable of <code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code>.
Its primary purpose is to proxy <code><a title="refinery.lib.argformats.DelayedArgument" href="../lib/argformats.html#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code> values which
can be computed only as soon as input data becomes available and which also have to be
recomputed for each input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L627-L706" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DelayedArgumentProxy:
    &#34;&#34;&#34;
    This class implements a proxy for the `args` member variable of `refinery.units.Unit`.
    Its primary purpose is to proxy `refinery.lib.argformats.DelayedArgument` values which
    can be computed only as soon as input data becomes available and which also have to be
    recomputed for each input.
    &#34;&#34;&#34;

    def __copy__(self):
        cls = self.__class__
        clone = cls.__new__(cls)
        clone._store(
            _argv=self._argv,
            _argo=list(self._argo),
            _args=dict(self._args),
            _done=self._done,
            _guid=self._guid,
        )
        return clone

    def __init__(self, argv, argo):
        args = {}
        done = True
        for name, value in vars(argv).items():
            if not pending(value):
                args[name] = value
            else:
                done = False
        self._store(
            _argv=argv,
            _argo=list(argo),
            _args=args,
            _done=done,
            _guid=None,
        )

    def __neg__(self):
        return not self._done

    def __imatmul__(self, data: bytearray):
        &#34;&#34;&#34;
        Lock the current arguments for the given input `data`.
        &#34;&#34;&#34;
        identifier = id(data)
        if not self._done and identifier != self._guid:
            self._store(_guid=identifier)
            for name in self._argo:
                value = getattr(self._argv, name, None)
                if value and pending(value):
                    self._args[name] = manifest(value, data)
        return self

    def _store(self, **kwargs):
        self.__dict__.update(kwargs)

    def __getattr__(self, name):
        try:
            return super().__getattr__(name)
        except AttributeError:
            pass
        try:
            return self._args[name]
        except KeyError:
            pass
        try:
            value = getattr(self._argv, name)
        except AttributeError as E:
            raise AttributeError(F&#39;Argument {name} not set.&#39;) from E
        if not value or not pending(value):
            return value
        raise AttributeError(F&#39;the value {name} cannot be accessed until data is available.&#39;)

    def __setattr__(self, name, value):
        if not hasattr(self._argv, name):
            self._argo.append(name)
        if pending(value):
            self._store(_done=False)
        else:
            self._args[name] = value
        return setattr(self._argv, name, value)</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit"><code class="flex name class">
<span>class <span class="ident">Unit</span></span>
<span>(</span><span>**keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>The base class for all refinery units. It implements a small set of globally
available options and the handling for multiple inputs and outputs. All units
implement the <em>framing</em> syntax for producing multiple outputs and ingesting
multiple inputs in a common format. For more details, see <code><a title="refinery.lib.frame" href="../lib/frame.html">refinery.lib.frame</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L709-L1307" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Unit(metaclass=Executable, abstract=True):
    &#34;&#34;&#34;
    The base class for all refinery units. It implements a small set of globally
    available options and the handling for multiple inputs and outputs. All units
    implement the _framing_ syntax for producing multiple outputs and ingesting
    multiple inputs in a common format. For more details, see `refinery.lib.frame`.
    &#34;&#34;&#34;
    @property
    def is_reversible(self) -&gt; bool:
        return self.__class__.is_reversible

    @property
    def codec(self) -&gt; str:
        return self.__class__.codec

    @property
    def name(self) -&gt; str:
        return self.__class__.name

    @property
    def log_level(self) -&gt; LogLevel:
        &#34;&#34;&#34;
        Returns the current log level as an element of `refinery.units.LogLevel`.
        &#34;&#34;&#34;
        try:
            return LogLevel.NONE if self.args.quiet else LogLevel(min(len(LogLevel) - 2, self.args.verbose))
        except AttributeError:
            return LogLevel.DETACHED

    @log_level.setter
    def log_level(self, value: LogLevel) -&gt; None:
        self.args.verbose = int(value)

    def log_detach(self) -&gt; None:
        self.log_level = LogLevel.DETACHED
        self.args.quiet = False

    def __iter__(self):
        return self

    def _exception_handler(self, exception: BaseException):
        if self.log_level &lt;= LogLevel.DETACHED:
            raise
        elif isinstance(exception, RefineryCriticalException):
            self.log_warn(F&#39;critical error, terminating: {exception}&#39;)
            raise
        elif isinstance(exception, VariableMissing):
            self.log_warn(&#39;critical error:&#39;, exception)
            raise RefineryCriticalException
        elif isinstance(exception, GeneratorExit):
            raise
        elif isinstance(exception, RefineryPartialResult):
            if not self.log_level:
                return None
            elif not self.log_warn(F&#39;error, partial result returned: {exception}&#39;):
                raise exception
            return exception.partial
        else:
            self.log_warn(F&#39;unexpected exception of type {exception.__class__.__name__}; {exception!s}&#39;)

        if self.log_debug():
            import traceback
            traceback.print_exc(file=sys.stderr)

    def __next__(self):
        if not self._chunks:
            self._chunks = iter(self._framehandler)
        while True:
            try:
                return next(self._chunks)
            except RefineryCriticalException as R:
                raise StopIteration from R

    @property
    def _framehandler(self) -&gt; Framed:
        if self._framed:
            return self._framed

        op = self.reverse if self.args.reverse else self.process

        def normalized_action(data: ByteString) -&gt; Iterable[ByteString]:
            try:
                result = op(data)
                if inspect.isgenerator(result):
                    yield from filter(lambda x: x is not None, result)
                elif result is not None:
                    yield result
            except BaseException as B:
                result = self._exception_handler(B)
                if result is not None:
                    yield result

        self._framed = Framed(
            normalized_action,
            self.source,
            self.args.nesting,
            self.filter
        )
        return self._framed

    def filter(self, inputs: Iterable[Chunk]) -&gt; Iterable[Chunk]:
        &#34;&#34;&#34;
        Receives an iterable of `refinery.lib.frame.Chunk`s and yields only those that
        should be processed. The default implementation returns the iterator without
        change; this member function is designed to be overloaded by child classes of
        `refinery.units.Unit` to allow inspection of an entire frame layer and altering
        it before `refinery.units.Unit.process` is called on the individual chunks.
        &#34;&#34;&#34;
        return inputs

    @property
    def source(self):
        &#34;&#34;&#34;
        Represents a unit or binary IO stream which has been attached to this unit as its
        source of input data.
        &#34;&#34;&#34;
        return self._source

    @source.setter
    def source(self, stream):
        if isinstance(stream, self.__class__.__class__):
            stream = stream()
        if not isinstance(stream, self.__class__):
            self._framed = None
            self._chunks = None
        self._source = stream

    @property
    def nozzle(self) -&gt; &#39;Unit&#39;:
        &#34;&#34;&#34;
        The nozzle is defined recursively as the nozzle of `refinery.units.Unit.source`
        and `self` if no such thing exists. In other words, it is the leftmost unit in
        a pipeline, where data should be inserted for processing.
        &#34;&#34;&#34;
        try:
            return self.source.nozzle
        except AttributeError:
            return self

    def __getitem__(self, unit: &#39;Unit&#39;):
        if isinstance(unit, type):
            unit = unit()
        alpha = self.__copy__()
        omega = unit.__copy__()
        alpha.args.nesting += 1
        omega.args.nesting -= 1
        omega.nozzle.source = alpha
        return omega

    def __ror__(self, stream: Union[BinaryIO, ByteString]):
        if not isbuffer(stream):
            self.nozzle.source = stream
            return self
        return self(stream)

    def __or__(self, stream: Union[BinaryIO, &#39;Unit&#39;]):
        try:
            if isinstance(stream, type):
                stream = stream()
            return stream.__copy__().__ror__(self)
        except AttributeError:
            self._target = stream

        if not self._target.writable():
            return

        def cname(x): return x.lower().replace(&#39;-&#39;, &#39;&#39;)

        if self.isatty and cname(self.codec) != cname(sys.stdout.encoding):
            def recode(chunk):
                import codecs
                return codecs.encode(
                    codecs.decode(chunk, self.codec, errors=&#39;backslashreplace&#39;),
                    sys.stdout.encoding
                )
        else:
            def recode(chunk): return chunk

        for last, chunk in lookahead(self):
            if (
                not last
                and (self._framehandler.unframed or self._framehandler.framebreak)
                and not chunk.endswith(B&#39;\n&#39;)
                and not self.args.squeeze
            ):
                chunk += B&#39;\n&#39;
            try:
                self._target.write(recode(chunk))
                self._target.flush()
            except AttributeError:
                pass
            except (BrokenPipeError, OSError) as E:
                if isinstance(E, BrokenPipeError) or E.errno != 32:
                    # This happens when the next unit does not consume everything
                    # we send. For example, this can happen when a large file is
                    # read in chunks and the pick unit is used to select only the
                    # first few of these.
                    self.log_info(F&#39;cannot send to next unit: {E}&#39;)
                break

        try:
            if self.isatty and not chunk.endswith(B&#39;\n&#39;):
                self._target.write(B&#39;\n&#39;)
                self._target.flush()
        except (NameError, AttributeError):
            pass

        return self._target

    def read(self, bytecount: int = -1) -&gt; bytes:
        &#34;&#34;&#34;
        Reads bytes from the output stream of this unit.
        &#34;&#34;&#34;
        if not bytecount or bytecount &lt; 0:
            return self.read1()
        bfr = bytearray(bytecount)
        offset = 0
        while offset &lt; bytecount:
            tmp = self.read1(bytecount - offset)
            if not tmp:
                del bfr[offset:]
                break
            end = offset + len(tmp)
            bfr[offset:end] = tmp
            offset = end
        return bytes(bfr)

    def read1(self, bytecount: int = -1) -&gt; bytes:
        &#34;&#34;&#34;
        Performs a single read against the output stream of this unit and returns
        the result.
        &#34;&#34;&#34;
        try:
            out = self._buffer or next(self)
            if bytecount and bytecount &gt; 0:
                out, self._buffer = out[:bytecount], out[bytecount:]
            elif self._buffer:
                self._buffer = B&#39;&#39;
            return out
        except StopIteration:
            return B&#39;&#39;

    def __call__(self, data: Optional[ByteString] = None) -&gt; bytes:
        with io.BytesIO(data) if data else open(os.devnull, &#39;rb&#39;) as stdin:
            with io.BytesIO() as stdout:
                return (stdin | self | stdout).getvalue()

    def process(self, data: ByteString) -&gt; Union[Optional[ByteString], Iterable[ByteString]]:
        &#34;&#34;&#34;
        This routine is overridden by children of `refinery.units.Unit` to define how
        the unit processes a given chunk of binary data.
        &#34;&#34;&#34;
        return data

    def log_warn(self, *messages) -&gt; bool:
        &#34;&#34;&#34;
        Call `refinery.units.Unit.output` for each provided message if and only if the
        current log level is at least `refinery.units.LogLevel.WARN`.
        &#34;&#34;&#34;
        rv = self.log_level &gt;= LogLevel.WARN
        if rv and messages:
            self.output(*messages)
        return rv

    def log_info(self, *messages) -&gt; bool:
        &#34;&#34;&#34;
        Call `refinery.units.Unit.output` for each provided message if and only if the
        current log level is at least `refinery.units.LogLevel.INFO`.
        &#34;&#34;&#34;
        rv = self.log_level &gt;= LogLevel.INFO
        if rv and messages:
            self.output(*messages)
        return rv

    def log_debug(self, *messages) -&gt; bool:
        &#34;&#34;&#34;
        Call `refinery.units.Unit.output` for each provided message if and only if the
        current log level is at least `refinery.units.LogLevel.DEBUG`.
        &#34;&#34;&#34;
        rv = self.log_level &gt;= LogLevel.DEBUG
        if rv and messages:
            self.output(*messages)
        return rv

    def output(self, *messages) -&gt; None:
        &#34;&#34;&#34;
        Logs the provided messages to stderr, prefixed with the current unit&#39;s name.
        The routine accepts both string and byte type arguments. Bytestrings are
        decoded with the default codec, using the &#39;backslashreplace&#39; error handler.
        Does not produce any output if the quiet switch has been enabled via the
        command line arguments.
        &#34;&#34;&#34;
        if not self.args.quiet:
            return self._output(*messages)

    @property
    def isatty(self) -&gt; bool:
        try:
            return self._target.isatty()
        except AttributeError:
            return False

    @classmethod
    def _output(cls, *messages) -&gt; None:
        def transform(x):
            try: x = x()
            except TypeError: pass
            if isinstance(x, str):
                return x
            if isinstance(x, (bytes, bytearray, memoryview)):
                import codecs
                return codecs.decode(x, cls.codec, errors=&#39;backslashreplace&#39;)
            return str(x)
        message = &#39; &#39;.join(transform(msg) for msg in messages)
        print(F&#39;{cls.name}: {message}&#39;, file=sys.stderr)

    @classmethod
    def _interface(cls, argp: ArgumentParser) -&gt; ArgumentParser:
        &#34;&#34;&#34;
        Receives a reference to an `ArgumentParser` object. This parser will be used to parse
        the command line for this unit into the member variable called `args`.
        &#34;&#34;&#34;
        base = argp.add_argument_group(&#39;generic options&#39;)

        base.add_argument(&#39;-h&#39;, &#39;--help&#39;, action=&#39;help&#39;, help=&#39;Show this help message and exit.&#39;)
        base.set_defaults(reverse=False, squeeze=False)

        if cls.is_reversible:
            base.add_argument(&#39;-R&#39;, &#39;--reverse&#39;, action=&#39;store_true&#39;, help=&#39;Use the reverse operation.&#39;)

        if cls.process.chunked or (cls.is_reversible and cls.reverse.chunked):
            base.add_argument(&#39;-Z&#39;, &#39;--squeeze&#39;, action=&#39;store_true&#39;, help=&#39;Fuse outputs, do not insert line breaks.&#39;)

        base.add_argument(&#39;-Q&#39;, &#39;--quiet&#39;, action=&#39;store_true&#39;, help=&#39;Disables all log output.&#39;)
        base.add_argument(&#39;-0&#39;, &#39;--devnull&#39;, action=&#39;store_true&#39;, help=&#39;Do not produce any output.&#39;)
        base.add_argument(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;count&#39;, default=LogLevel.WARN,
            help=&#39;Specify up to two times to increase log level.&#39;)
        argp.add_argument(&#39;--debug-timing&#39;, dest=&#39;dtiming&#39;, action=&#39;store_true&#39;, help=SUPPRESS)

        groups = {None: argp}

        for argument in reversed(cls.argspec.values()):
            gp = argument.group
            if gp not in groups:
                groups[gp] = argp.add_mutually_exclusive_group()
            groups[gp].add_argument @ argument

        return argp

    @classmethod
    def argparser(cls, *args, **keywords):
        cols = get_terminal_size()
        args = list(args)

        class ArgumentParserWithKeywordHooks(ArgumentParser):
            def _add_action(self, action):

                class RememberOrder:
                    def __getattr__(self, name): return getattr(action, name)
                    def __setattr__(self, name, value): return setattr(action, name, value)

                    def __call__(self, parser, ns, values, opt=None):
                        if self.dest not in parser.order:
                            parser.order.append(self.dest)
                        return action(parser, ns, values, opt)

                if action.dest in keywords:
                    action.required = False
                    if callable(getattr(action, &#39;type&#39;, None)):
                        value = keywords[action.dest]
                        if value is not None and isinstance(value, str) and action.type is not str:
                            keywords[action.dest] = action.type(keywords[action.dest])

                return super()._add_action(RememberOrder())

            def _parse_optional(self, arg_string):
                if isinstance(arg_string, str):
                    return super()._parse_optional(arg_string)

            def error_commandline(self, message):
                super().error(message)

            def error(self, message):
                parser_instance = self
                raise ArgparseError(parser_instance, message)

            def parse_args(self):
                self.order = []
                args_for_parser = args
                if args and args[~0] and isinstance(args[~0], str):
                    nestarg = args[~0]
                    nesting = len(nestarg)
                    if nestarg == &#39;]&#39; * nesting:
                        self.set_defaults(nesting=-nesting)
                        args_for_parser = args[:~0]
                    elif nestarg == &#39;[&#39; * nesting:
                        self.set_defaults(nesting=nesting)
                        args_for_parser = args[:~0]
                self.set_defaults(**keywords)
                try:
                    parsed = super().parse_args(args=args_for_parser)
                except ArgumentError as e:
                    self.error(str(e))
                for name in keywords:
                    param = getattr(parsed, name, None)
                    if param != keywords[name]:
                        self.error(
                            F&#39;parameter &#34;{name}&#34; duplicated with conflicting &#39;
                            F&#39;values {param} and {keywords[name]}&#39;
                        )
                for name in vars(parsed):
                    if name not in self.order:
                        self.order.append(name)
                return parsed

        class LineWrapRawTextHelpFormatter(RawDescriptionHelpFormatter):
            def __init__(self, prog, indent_increment=2, max_help_position=30, width=None):
                super().__init__(prog, indent_increment, max_help_position, width=cols)

            def add_text(self, text):
                if isinstance(text, str):
                    text = terminalfit(text, width=cols)
                return super().add_text(text)

            def _format_action_invocation(self, action):
                if not action.option_strings:
                    metavar, = self._metavar_formatter(action, action.dest)(1)
                    return metavar
                else:
                    parts = []
                    if action.nargs == 0:
                        parts.extend(action.option_strings)
                    else:
                        default = action.dest.upper()
                        args_string = self._format_args(action, default)
                        for option_string in action.option_strings:
                            parts.append(str(option_string))
                        parts[-1] += F&#39; {args_string}&#39;
                    return &#39;, &#39;.join(parts)

        argp = ArgumentParserWithKeywordHooks(
            prog=cls.name,
            description=documentation(cls),
            formatter_class=LineWrapRawTextHelpFormatter,
            add_help=False
        )

        argp.set_defaults(nesting=0)
        return cls._interface(argp)

    @staticmethod
    def superinit(spc, **keywords):
        &#34;&#34;&#34;
        This function uses `refinery.lib.tools.autoinvoke` to call the `__init__` function of `super` with
        by taking all required parameters from `keywords`, ignoring the rest. Calling
        ```
        self.superinit(super(), **vars())
        ```
        will therefore perform initialization of the parent class without having to forward all parameters
        manually. This is a convenience feature which reduces code bloat when many parameters have to be
        forwarded, see e.g. `refinery.units.pattern.carve.carve` for an example.
        &#34;&#34;&#34;
        args = inspect.signature(spc.__thisclass__.__init__).parameters
        keep = list(skipfirst(args))
        junk = [a for a in keywords if a not in keep]
        for j in junk: del keywords[j]
        for a in args.values():
            if a.kind is a.VAR_KEYWORD:
                keywords.update(keywords.pop(a.name, {}))
        try:
            if spc.__init__.__func__ is Unit.__init__:
                return spc.__init__(**keywords)
        except AttributeError:
            pass
        return autoinvoke(spc.__init__, keywords)

    @classmethod
    def assemble(cls, *args, **keywords):
        &#34;&#34;&#34;
        Creates a unit from the given arguments and keywords. The given keywords are used to overwrite any
        previously specified defaults for the argument parser of the unit, then this modified parser is
        used to parse the given list of arguments as though they were given on the command line. The parser
        results are used to construct an instance of the unit, this object is consequently returned.
        &#34;&#34;&#34;
        argp = cls.argparser(*args, **keywords)
        args = argp.parse_args()

        try:
            unit = autoinvoke(cls, args.__dict__)
        except ValueError as E:
            argp.error(str(E))

        unit.args._store(_argo=argp.order)
        unit.args.quiet = args.quiet

        unit.args.squeeze = args.squeeze
        unit.args.dtiming = args.dtiming
        unit.args.nesting = args.nesting
        unit.args.reverse = args.reverse
        unit.args.devnull = args.devnull
        unit.args.verbose = args.verbose

        return unit

    def __copy__(self):
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.__dict__.update(self.__dict__)
    #   TODO: Preferably, units should keep all their information in args, making
    #         the above __dict__ update unnecessary.
    #   clone._buffer = self._buffer
    #   clone._source = self._source
        clone._target = None
        clone._framed = None
        clone._chunks = None
        clone.args = self.args.__copy__()
        return clone

    def __init__(self, **keywords):
        self._buffer = B&#39;&#39;
        self._source = None
        self._target = None
        self._framed = None
        self._chunks = None

        keywords.update(dict(
            dtiming=False,
            nesting=0,
            reverse=False,
            squeeze=False,
            devnull=False,
            verbose=LogLevel.DETACHED,
            quiet=False,
        ))
        # Since Python 3.6, functions always preserve the order of the keyword
        # arguments passed to them (see PEP 468).
        self.args = DelayedArgumentProxy(Namespace(**keywords), list(keywords))

    def detach(self):
        &#34;&#34;&#34;
        When a unit is created using the `refinery.units.Unit.assemble` method, it is attached to a
        logger by default (in less abstract terms, the `refinery.units.Unit.log_level` property is
        set to a positive value). This method detaches the unit from its logger, which also means that
        any exceptions that occur during runtime will be raised to the caller.
        &#34;&#34;&#34;
        self.log_level = LogLevel.DETACHED
        return self

    @classmethod
    def run(cls, argv=None, stream=None) -&gt; None:
        &#34;&#34;&#34;
        Implements command line execution. As `refinery.units.Unit` is an `refinery.units.Executable`,
        this method will be executed when a class inheriting from `refinery.units.Unit` is defined in
        the current `__main__` module.
        &#34;&#34;&#34;
        argv = argv if argv is not None else sys.argv[1:]

        if stream is None:
            stream = open(os.devnull, &#39;rb&#39;) if sys.stdin.isatty() else sys.stdin.buffer

        with stream as source:
            try:
                unit = cls.assemble(*argv)
            except ArgparseError as ap:
                ap.parser.error_commandline(str(ap))
            except Exception as msg:
                cls._output(&#39;initialization failed:&#39;, msg)
                return

            try:
                loglevel = os.environ[&#39;REFINERY_VERBOSITY&#39;]
            except KeyError:
                pass
            else:
                try:
                    loglevel = LogLevel[loglevel]
                except KeyError:
                    loglevels = &#39;, &#39;.join(ll.name for ll in LogLevel)
                    unit.log_warn(F&#39;unknown verbosity {loglevel!r}, pick from {loglevels}&#39;)
                else:
                    unit.log_level = loglevel

            if unit.args.dtiming:
                from time import process_time
                start_clock = process_time()
                unit.output(&#39;starting clock: {:.4f}&#39;.format(start_clock))

            try:
                with open(os.devnull, &#39;wb&#39;) if unit.args.devnull else sys.stdout.buffer as output:
                    source | unit | output
            except KeyboardInterrupt:
                unit.output(&#39;aborting due to keyboard interrupt&#39;)
            except OSError:
                pass

            if unit.args.dtiming:
                stop_clock = process_time()
                unit.output(&#39;stopping clock: {:.4f}&#39;.format(stop_clock))
                unit.output(&#39;time delta was: {:.4f}&#39;.format(stop_clock - start_clock))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.blockwise.BlockTransformation" href="blockwise/index.html#refinery.units.blockwise.BlockTransformation">BlockTransformation</a></li>
<li><a title="refinery.units.compression.ap.aplib" href="compression/ap.html#refinery.units.compression.ap.aplib">aplib</a></li>
<li><a title="refinery.units.compression.bz2.bz2" href="compression/bz2.html#refinery.units.compression.bz2.bz2">bz2</a></li>
<li><a title="refinery.units.compression.decompress.decompress" href="compression/decompress.html#refinery.units.compression.decompress.decompress">decompress</a></li>
<li><a title="refinery.units.compression.gz.gz" href="compression/gz.html#refinery.units.compression.gz.gz">gz</a></li>
<li><a title="refinery.units.compression.lz.lzma" href="compression/lz.html#refinery.units.compression.lz.lzma">lzma</a></li>
<li><a title="refinery.units.compression.lznt1.lznt1" href="compression/lznt1.html#refinery.units.compression.lznt1.lznt1">lznt1</a></li>
<li><a title="refinery.units.compression.zl.zl" href="compression/zl.html#refinery.units.compression.zl.zl">zl</a></li>
<li><a title="refinery.units.crypto.cipher.CipherUnit" href="crypto/cipher/index.html#refinery.units.crypto.cipher.CipherUnit">CipherUnit</a></li>
<li><a title="refinery.units.crypto.cipher.rncrypt.rncrypt" href="crypto/cipher/rncrypt.html#refinery.units.crypto.cipher.rncrypt.rncrypt">rncrypt</a></li>
<li><a title="refinery.units.crypto.cipher.rot.rot" href="crypto/cipher/rot.html#refinery.units.crypto.cipher.rot.rot">rot</a></li>
<li><a title="refinery.units.crypto.cipher.rsa.rsa" href="crypto/cipher/rsa.html#refinery.units.crypto.cipher.rsa.rsa">rsa</a></li>
<li><a title="refinery.units.crypto.cipher.secstr.secstr" href="crypto/cipher/secstr.html#refinery.units.crypto.cipher.secstr.secstr">secstr</a></li>
<li><a title="refinery.units.crypto.cipher.vigenere.vigenere" href="crypto/cipher/vigenere.html#refinery.units.crypto.cipher.vigenere.vigenere">vigenere</a></li>
<li><a title="refinery.units.crypto.hash.HashUnit" href="crypto/hash/index.html#refinery.units.crypto.hash.HashUnit">HashUnit</a></li>
<li><a title="refinery.units.crypto.keyderive.KeyDerivation" href="crypto/keyderive/index.html#refinery.units.crypto.keyderive.KeyDerivation">KeyDerivation</a></li>
<li><a title="refinery.units.crypto.keyderive.kblob.kblob" href="crypto/keyderive/kblob.html#refinery.units.crypto.keyderive.kblob.kblob">kblob</a></li>
<li><a title="refinery.units.encoding.b32.b32" href="encoding/b32.html#refinery.units.encoding.b32.b32">b32</a></li>
<li><a title="refinery.units.encoding.b64.b64" href="encoding/b64.html#refinery.units.encoding.b64.b64">b64</a></li>
<li><a title="refinery.units.encoding.b85.b85" href="encoding/b85.html#refinery.units.encoding.b85.b85">b85</a></li>
<li><a title="refinery.units.encoding.base.base" href="encoding/base.html#refinery.units.encoding.base.base">base</a></li>
<li><a title="refinery.units.encoding.cp1252.cp1252" href="encoding/cp1252.html#refinery.units.encoding.cp1252.cp1252">cp1252</a></li>
<li><a title="refinery.units.encoding.esc.esc" href="encoding/esc.html#refinery.units.encoding.esc.esc">esc</a></li>
<li><a title="refinery.units.encoding.hex.hex" href="encoding/hex.html#refinery.units.encoding.hex.hex">hex</a></li>
<li><a title="refinery.units.encoding.htm.html" href="encoding/htm.html#refinery.units.encoding.htm.html">html</a></li>
<li><a title="refinery.units.encoding.netbios.netbios" href="encoding/netbios.html#refinery.units.encoding.netbios.netbios">netbios</a></li>
<li><a title="refinery.units.encoding.ps1str.ps1str" href="encoding/ps1str.html#refinery.units.encoding.ps1str.ps1str">ps1str</a></li>
<li><a title="refinery.units.encoding.recode.recode" href="encoding/recode.html#refinery.units.encoding.recode.recode">recode</a></li>
<li><a title="refinery.units.encoding.u16.u16" href="encoding/u16.html#refinery.units.encoding.u16.u16">u16</a></li>
<li><a title="refinery.units.encoding.url.url" href="encoding/url.html#refinery.units.encoding.url.url">url</a></li>
<li><a title="refinery.units.encoding.vbe.vbe" href="encoding/vbe.html#refinery.units.encoding.vbe.vbe">vbe</a></li>
<li><a title="refinery.units.formats.MemoryExtractorUnit" href="formats/index.html#refinery.units.formats.MemoryExtractorUnit">MemoryExtractorUnit</a></li>
<li><a title="refinery.units.formats.PathExtractorUnit" href="formats/index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.formats.deserialize_java.dsjava" href="formats/deserialize_java.html#refinery.units.formats.deserialize_java.dsjava">dsjava</a></li>
<li><a title="refinery.units.formats.deserialize_php.dsphp" href="formats/deserialize_php.html#refinery.units.formats.deserialize_php.dsphp">dsphp</a></li>
<li><a title="refinery.units.formats.httpresponse.httpresponse" href="formats/httpresponse.html#refinery.units.formats.httpresponse.httpresponse">httpresponse</a></li>
<li><a title="refinery.units.formats.office.xlxtr.xlxtr" href="formats/office/xlxtr.html#refinery.units.formats.office.xlxtr.xlxtr">xlxtr</a></li>
<li><a title="refinery.units.formats.pe.dotnet.JSONEncoderUnit" href="formats/pe/dotnet/index.html#refinery.units.formats.pe.dotnet.JSONEncoderUnit">JSONEncoderUnit</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dncfx.dncfx" href="formats/pe/dotnet/dncfx.html#refinery.units.formats.pe.dotnet.dncfx.dncfx">dncfx</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnstr.dnstr" href="formats/pe/dotnet/dnstr.html#refinery.units.formats.pe.dotnet.dnstr.dnstr">dnstr</a></li>
<li><a title="refinery.units.formats.pe.pemeta.pemeta" href="formats/pe/pemeta.html#refinery.units.formats.pe.pemeta.pemeta">pemeta</a></li>
<li><a title="refinery.units.formats.pe.peoverlay.peoverlay" href="formats/pe/peoverlay.html#refinery.units.formats.pe.peoverlay.peoverlay">peoverlay</a></li>
<li><a title="refinery.units.formats.pe.perc.perc" href="formats/pe/perc.html#refinery.units.formats.pe.perc.perc">perc</a></li>
<li><a title="refinery.units.formats.pe.pesig.pesig" href="formats/pe/pesig.html#refinery.units.formats.pe.pesig.pesig">pesig</a></li>
<li><a title="refinery.units.formats.pe.pestrip.pestrip" href="formats/pe/pestrip.html#refinery.units.formats.pe.pestrip.pestrip">pestrip</a></li>
<li><a title="refinery.units.formats.pkcs7.pkcs7" href="formats/pkcs7.html#refinery.units.formats.pkcs7.pkcs7">pkcs7</a></li>
<li><a title="refinery.units.meta.FrameSlicer" href="meta/index.html#refinery.units.meta.FrameSlicer">FrameSlicer</a></li>
<li><a title="refinery.units.meta.chop.chop" href="meta/chop.html#refinery.units.meta.chop.chop">chop</a></li>
<li><a title="refinery.units.meta.couple.couple" href="meta/couple.html#refinery.units.meta.couple.couple">couple</a></li>
<li><a title="refinery.units.meta.dedup.dedup" href="meta/dedup.html#refinery.units.meta.dedup.dedup">dedup</a></li>
<li><a title="refinery.units.meta.emit.emit" href="meta/emit.html#refinery.units.meta.emit.emit">emit</a></li>
<li><a title="refinery.units.meta.fread.fread" href="meta/fread.html#refinery.units.meta.fread.fread">fread</a></li>
<li><a title="refinery.units.meta.mpop.mpop" href="meta/mpop.html#refinery.units.meta.mpop.mpop">mpop</a></li>
<li><a title="refinery.units.meta.mput.mput" href="meta/mput.html#refinery.units.meta.mput.mput">mput</a></li>
<li><a title="refinery.units.meta.nop.nop" href="meta/nop.html#refinery.units.meta.nop.nop">nop</a></li>
<li><a title="refinery.units.meta.pad.pad" href="meta/pad.html#refinery.units.meta.pad.pad">pad</a></li>
<li><a title="refinery.units.meta.pick.pick" href="meta/pick.html#refinery.units.meta.pick.pick">pick</a></li>
<li><a title="refinery.units.meta.sep.sep" href="meta/sep.html#refinery.units.meta.sep.sep">sep</a></li>
<li><a title="refinery.units.meta.sorted.sorted" href="meta/sorted.html#refinery.units.meta.sorted.sorted">sorted</a></li>
<li><a title="refinery.units.misc.autoxor.autoxor" href="misc/autoxor.html#refinery.units.misc.autoxor.autoxor">autoxor</a></li>
<li><a title="refinery.units.misc.binpng.binpng" href="misc/binpng.html#refinery.units.misc.binpng.binpng">binpng</a></li>
<li><a title="refinery.units.misc.datefix.datefix" href="misc/datefix.html#refinery.units.misc.datefix.datefix">datefix</a></li>
<li><a title="refinery.units.obfuscation.Deobfuscator" href="obfuscation/index.html#refinery.units.obfuscation.Deobfuscator">Deobfuscator</a></li>
<li><a title="refinery.units.obfuscation.vba.vba.deob_vba_chr_literals" href="obfuscation/vba/vba.html#refinery.units.obfuscation.vba.vba.deob_vba_chr_literals">deob_vba_chr_literals</a></li>
<li><a title="refinery.units.pattern.PatternExtractorBase" href="pattern/index.html#refinery.units.pattern.PatternExtractorBase">PatternExtractorBase</a></li>
<li><a title="refinery.units.pattern.carve_json.carve_json" href="pattern/carve_json.html#refinery.units.pattern.carve_json.carve_json">carve_json</a></li>
<li><a title="refinery.units.pattern.carve_pe.carve_pe" href="pattern/carve_pe.html#refinery.units.pattern.carve_pe.carve_pe">carve_pe</a></li>
<li><a title="refinery.units.pattern.carve_xml.carve_xml" href="pattern/carve_xml.html#refinery.units.pattern.carve_xml.carve_xml">carve_xml</a></li>
<li><a title="refinery.units.pattern.carve_zip.carve_zip" href="pattern/carve_zip.html#refinery.units.pattern.carve_zip.carve_zip">carve_zip</a></li>
<li><a title="refinery.units.pattern.defang.defang" href="pattern/defang.html#refinery.units.pattern.defang.defang">defang</a></li>
<li><a title="refinery.units.pattern.mimewords.mimewords" href="pattern/mimewords.html#refinery.units.pattern.mimewords.mimewords">mimewords</a></li>
<li><a title="refinery.units.pattern.urlguards.urlguards" href="pattern/urlguards.html#refinery.units.pattern.urlguards.urlguards">urlguards</a></li>
<li><a title="refinery.units.sinks.HexViewer" href="sinks/index.html#refinery.units.sinks.HexViewer">HexViewer</a></li>
<li><a title="refinery.units.sinks.asm.asm" href="sinks/asm.html#refinery.units.sinks.asm.asm">asm</a></li>
<li><a title="refinery.units.sinks.dump.dump" href="sinks/dump.html#refinery.units.sinks.dump.dump">dump</a></li>
<li><a title="refinery.units.sinks.ppjson.ppjson" href="sinks/ppjson.html#refinery.units.sinks.ppjson.ppjson">ppjson</a></li>
<li><a title="refinery.units.sinks.ppxml.ppxml" href="sinks/ppxml.html#refinery.units.sinks.ppxml.ppxml">ppxml</a></li>
<li><a title="refinery.units.strings.cca.cca" href="strings/cca.html#refinery.units.strings.cca.cca">cca</a></li>
<li><a title="refinery.units.strings.ccp.ccp" href="strings/ccp.html#refinery.units.strings.ccp.ccp">ccp</a></li>
<li><a title="refinery.units.strings.cfmt.cfmt" href="strings/cfmt.html#refinery.units.strings.cfmt.cfmt">cfmt</a></li>
<li><a title="refinery.units.strings.clower.clower" href="strings/clower.html#refinery.units.strings.clower.clower">clower</a></li>
<li><a title="refinery.units.strings.cupper.cupper" href="strings/cupper.html#refinery.units.strings.cupper.cupper">cupper</a></li>
<li><a title="refinery.units.strings.rep.rep" href="strings/rep.html#refinery.units.strings.rep.rep">rep</a></li>
<li><a title="refinery.units.strings.repl.repl" href="strings/repl.html#refinery.units.strings.repl.repl">repl</a></li>
<li><a title="refinery.units.strings.snip.snip" href="strings/snip.html#refinery.units.strings.snip.snip">snip</a></li>
<li><a title="refinery.units.strings.stretch.stretch" href="strings/stretch.html#refinery.units.strings.stretch.stretch">stretch</a></li>
<li><a title="refinery.units.strings.termfit.termfit" href="strings/termfit.html#refinery.units.strings.termfit.termfit">termfit</a></li>
<li><a title="refinery.units.strings.trim.trim" href="strings/trim.html#refinery.units.strings.trim.trim">trim</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.Unit.is_reversible"><code class="name">var <span class="ident">is_reversible</span></code></dt>
<dd>
<section class="desc"><p>This property is <code>True</code> if and only if the unit has a member function
named <code>reverse</code>. By convention, this member function implements the
inverse of <code><a title="refinery.units.Unit.process" href="#refinery.units.Unit.process">Unit.process()</a></code>.</p></section>
</dd>
<dt id="refinery.units.Unit.codec"><code class="name">var <span class="ident">codec</span></code></dt>
<dd>
<section class="desc"><p>The default codec for encoding textual information between units.
The value of this property is hardcoded to <code>UTF8</code>.</p></section>
</dd>
<dt id="refinery.units.Unit.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.Unit.argspec"><code class="name">var <span class="ident">argspec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.Unit.argparser"><code class="name flex">
<span>def <span class="ident">argparser</span></span>(<span>*args, **keywords)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L1058-L1157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def argparser(cls, *args, **keywords):
    cols = get_terminal_size()
    args = list(args)

    class ArgumentParserWithKeywordHooks(ArgumentParser):
        def _add_action(self, action):

            class RememberOrder:
                def __getattr__(self, name): return getattr(action, name)
                def __setattr__(self, name, value): return setattr(action, name, value)

                def __call__(self, parser, ns, values, opt=None):
                    if self.dest not in parser.order:
                        parser.order.append(self.dest)
                    return action(parser, ns, values, opt)

            if action.dest in keywords:
                action.required = False
                if callable(getattr(action, &#39;type&#39;, None)):
                    value = keywords[action.dest]
                    if value is not None and isinstance(value, str) and action.type is not str:
                        keywords[action.dest] = action.type(keywords[action.dest])

            return super()._add_action(RememberOrder())

        def _parse_optional(self, arg_string):
            if isinstance(arg_string, str):
                return super()._parse_optional(arg_string)

        def error_commandline(self, message):
            super().error(message)

        def error(self, message):
            parser_instance = self
            raise ArgparseError(parser_instance, message)

        def parse_args(self):
            self.order = []
            args_for_parser = args
            if args and args[~0] and isinstance(args[~0], str):
                nestarg = args[~0]
                nesting = len(nestarg)
                if nestarg == &#39;]&#39; * nesting:
                    self.set_defaults(nesting=-nesting)
                    args_for_parser = args[:~0]
                elif nestarg == &#39;[&#39; * nesting:
                    self.set_defaults(nesting=nesting)
                    args_for_parser = args[:~0]
            self.set_defaults(**keywords)
            try:
                parsed = super().parse_args(args=args_for_parser)
            except ArgumentError as e:
                self.error(str(e))
            for name in keywords:
                param = getattr(parsed, name, None)
                if param != keywords[name]:
                    self.error(
                        F&#39;parameter &#34;{name}&#34; duplicated with conflicting &#39;
                        F&#39;values {param} and {keywords[name]}&#39;
                    )
            for name in vars(parsed):
                if name not in self.order:
                    self.order.append(name)
            return parsed

    class LineWrapRawTextHelpFormatter(RawDescriptionHelpFormatter):
        def __init__(self, prog, indent_increment=2, max_help_position=30, width=None):
            super().__init__(prog, indent_increment, max_help_position, width=cols)

        def add_text(self, text):
            if isinstance(text, str):
                text = terminalfit(text, width=cols)
            return super().add_text(text)

        def _format_action_invocation(self, action):
            if not action.option_strings:
                metavar, = self._metavar_formatter(action, action.dest)(1)
                return metavar
            else:
                parts = []
                if action.nargs == 0:
                    parts.extend(action.option_strings)
                else:
                    default = action.dest.upper()
                    args_string = self._format_args(action, default)
                    for option_string in action.option_strings:
                        parts.append(str(option_string))
                    parts[-1] += F&#39; {args_string}&#39;
                return &#39;, &#39;.join(parts)

    argp = ArgumentParserWithKeywordHooks(
        prog=cls.name,
        description=documentation(cls),
        formatter_class=LineWrapRawTextHelpFormatter,
        add_help=False
    )

    argp.set_defaults(nesting=0)
    return cls._interface(argp)</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.superinit"><code class="name flex">
<span>def <span class="ident">superinit</span></span>(<span>spc, **keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>This function uses <code><a title="refinery.lib.tools.autoinvoke" href="../lib/tools.html#refinery.lib.tools.autoinvoke">autoinvoke()</a></code> to call the <code>__init__</code> function of <code>super</code> with
by taking all required parameters from <code>keywords</code>, ignoring the rest. Calling</p>
<pre><code>self.superinit(super(), **vars())
</code></pre>
<p>will therefore perform initialization of the parent class without having to forward all parameters
manually. This is a convenience feature which reduces code bloat when many parameters have to be
forwarded, see e.g. <code><a title="refinery.units.pattern.carve.carve" href="pattern/carve.html#refinery.units.pattern.carve.carve">carve</a></code> for an example.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L1159-L1183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def superinit(spc, **keywords):
    &#34;&#34;&#34;
    This function uses `refinery.lib.tools.autoinvoke` to call the `__init__` function of `super` with
    by taking all required parameters from `keywords`, ignoring the rest. Calling
    ```
    self.superinit(super(), **vars())
    ```
    will therefore perform initialization of the parent class without having to forward all parameters
    manually. This is a convenience feature which reduces code bloat when many parameters have to be
    forwarded, see e.g. `refinery.units.pattern.carve.carve` for an example.
    &#34;&#34;&#34;
    args = inspect.signature(spc.__thisclass__.__init__).parameters
    keep = list(skipfirst(args))
    junk = [a for a in keywords if a not in keep]
    for j in junk: del keywords[j]
    for a in args.values():
        if a.kind is a.VAR_KEYWORD:
            keywords.update(keywords.pop(a.name, {}))
    try:
        if spc.__init__.__func__ is Unit.__init__:
            return spc.__init__(**keywords)
    except AttributeError:
        pass
    return autoinvoke(spc.__init__, keywords)</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.assemble"><code class="name flex">
<span>def <span class="ident">assemble</span></span>(<span>*args, **keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a unit from the given arguments and keywords. The given keywords are used to overwrite any
previously specified defaults for the argument parser of the unit, then this modified parser is
used to parse the given list of arguments as though they were given on the command line. The parser
results are used to construct an instance of the unit, this object is consequently returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L1185-L1211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def assemble(cls, *args, **keywords):
    &#34;&#34;&#34;
    Creates a unit from the given arguments and keywords. The given keywords are used to overwrite any
    previously specified defaults for the argument parser of the unit, then this modified parser is
    used to parse the given list of arguments as though they were given on the command line. The parser
    results are used to construct an instance of the unit, this object is consequently returned.
    &#34;&#34;&#34;
    argp = cls.argparser(*args, **keywords)
    args = argp.parse_args()

    try:
        unit = autoinvoke(cls, args.__dict__)
    except ValueError as E:
        argp.error(str(E))

    unit.args._store(_argo=argp.order)
    unit.args.quiet = args.quiet

    unit.args.squeeze = args.squeeze
    unit.args.dtiming = args.dtiming
    unit.args.nesting = args.nesting
    unit.args.reverse = args.reverse
    unit.args.devnull = args.devnull
    unit.args.verbose = args.verbose

    return unit</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>argv=None, stream=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements command line execution. As <code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code> is an <code><a title="refinery.units.Executable" href="#refinery.units.Executable">Executable</a></code>,
this method will be executed when a class inheriting from <code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code> is defined in
the current <code>__main__</code> module.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L1257-L1307" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def run(cls, argv=None, stream=None) -&gt; None:
    &#34;&#34;&#34;
    Implements command line execution. As `refinery.units.Unit` is an `refinery.units.Executable`,
    this method will be executed when a class inheriting from `refinery.units.Unit` is defined in
    the current `__main__` module.
    &#34;&#34;&#34;
    argv = argv if argv is not None else sys.argv[1:]

    if stream is None:
        stream = open(os.devnull, &#39;rb&#39;) if sys.stdin.isatty() else sys.stdin.buffer

    with stream as source:
        try:
            unit = cls.assemble(*argv)
        except ArgparseError as ap:
            ap.parser.error_commandline(str(ap))
        except Exception as msg:
            cls._output(&#39;initialization failed:&#39;, msg)
            return

        try:
            loglevel = os.environ[&#39;REFINERY_VERBOSITY&#39;]
        except KeyError:
            pass
        else:
            try:
                loglevel = LogLevel[loglevel]
            except KeyError:
                loglevels = &#39;, &#39;.join(ll.name for ll in LogLevel)
                unit.log_warn(F&#39;unknown verbosity {loglevel!r}, pick from {loglevels}&#39;)
            else:
                unit.log_level = loglevel

        if unit.args.dtiming:
            from time import process_time
            start_clock = process_time()
            unit.output(&#39;starting clock: {:.4f}&#39;.format(start_clock))

        try:
            with open(os.devnull, &#39;wb&#39;) if unit.args.devnull else sys.stdout.buffer as output:
                source | unit | output
        except KeyboardInterrupt:
            unit.output(&#39;aborting due to keyboard interrupt&#39;)
        except OSError:
            pass

        if unit.args.dtiming:
            stop_clock = process_time()
            unit.output(&#39;stopping clock: {:.4f}&#39;.format(stop_clock))
            unit.output(&#39;time delta was: {:.4f}&#39;.format(stop_clock - start_clock))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.Unit.log_level"><code class="name">var <span class="ident">log_level</span></code></dt>
<dd>
<section class="desc"><p>Returns the current log level as an element of <code><a title="refinery.units.LogLevel" href="#refinery.units.LogLevel">LogLevel</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L728-L736" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_level(self) -&gt; LogLevel:
    &#34;&#34;&#34;
    Returns the current log level as an element of `refinery.units.LogLevel`.
    &#34;&#34;&#34;
    try:
        return LogLevel.NONE if self.args.quiet else LogLevel(min(len(LogLevel) - 2, self.args.verbose))
    except AttributeError:
        return LogLevel.DETACHED</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.source"><code class="name">var <span class="ident">source</span></code></dt>
<dd>
<section class="desc"><p>Represents a unit or binary IO stream which has been attached to this unit as its
source of input data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L819-L825" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def source(self):
    &#34;&#34;&#34;
    Represents a unit or binary IO stream which has been attached to this unit as its
    source of input data.
    &#34;&#34;&#34;
    return self._source</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.nozzle"><code class="name">var <span class="ident">nozzle</span></code></dt>
<dd>
<section class="desc"><p>The nozzle is defined recursively as the nozzle of <code><a title="refinery.units.Unit.source" href="#refinery.units.Unit.source">Unit.source</a></code>
and <code>self</code> if no such thing exists. In other words, it is the leftmost unit in
a pipeline, where data should be inserted for processing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L836-L846" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def nozzle(self) -&gt; &#39;Unit&#39;:
    &#34;&#34;&#34;
    The nozzle is defined recursively as the nozzle of `refinery.units.Unit.source`
    and `self` if no such thing exists. In other words, it is the leftmost unit in
    a pipeline, where data should be inserted for processing.
    &#34;&#34;&#34;
    try:
        return self.source.nozzle
    except AttributeError:
        return self</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.isatty"><code class="name">var <span class="ident">isatty</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L1004-L1009" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def isatty(self) -&gt; bool:
    try:
        return self._target.isatty()
    except AttributeError:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.Unit.log_detach"><code class="name flex">
<span>def <span class="ident">log_detach</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L742-L744" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_detach(self) -&gt; None:
    self.log_level = LogLevel.DETACHED
    self.args.quiet = False</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, inputs)</span>
</code></dt>
<dd>
<section class="desc"><p>Receives an iterable of <code><a title="refinery.lib.frame.Chunk" href="../lib/frame.html#refinery.lib.frame.Chunk">Chunk</a></code>s and yields only those that
should be processed. The default implementation returns the iterator without
change; this member function is designed to be overloaded by child classes of
<code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code> to allow inspection of an entire frame layer and altering
it before <code><a title="refinery.units.Unit.process" href="#refinery.units.Unit.process">Unit.process()</a></code> is called on the individual chunks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L809-L817" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filter(self, inputs: Iterable[Chunk]) -&gt; Iterable[Chunk]:
    &#34;&#34;&#34;
    Receives an iterable of `refinery.lib.frame.Chunk`s and yields only those that
    should be processed. The default implementation returns the iterator without
    change; this member function is designed to be overloaded by child classes of
    `refinery.units.Unit` to allow inspection of an entire frame layer and altering
    it before `refinery.units.Unit.process` is called on the individual chunks.
    &#34;&#34;&#34;
    return inputs</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, bytecount=-1)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads bytes from the output stream of this unit.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L918-L934" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, bytecount: int = -1) -&gt; bytes:
    &#34;&#34;&#34;
    Reads bytes from the output stream of this unit.
    &#34;&#34;&#34;
    if not bytecount or bytecount &lt; 0:
        return self.read1()
    bfr = bytearray(bytecount)
    offset = 0
    while offset &lt; bytecount:
        tmp = self.read1(bytecount - offset)
        if not tmp:
            del bfr[offset:]
            break
        end = offset + len(tmp)
        bfr[offset:end] = tmp
        offset = end
    return bytes(bfr)</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.read1"><code class="name flex">
<span>def <span class="ident">read1</span></span>(<span>self, bytecount=-1)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs a single read against the output stream of this unit and returns
the result.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L936-L949" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read1(self, bytecount: int = -1) -&gt; bytes:
    &#34;&#34;&#34;
    Performs a single read against the output stream of this unit and returns
    the result.
    &#34;&#34;&#34;
    try:
        out = self._buffer or next(self)
        if bytecount and bytecount &gt; 0:
            out, self._buffer = out[:bytecount], out[bytecount:]
        elif self._buffer:
            self._buffer = B&#39;&#39;
        return out
    except StopIteration:
        return B&#39;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>This routine is overridden by children of <code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code> to define how
the unit processes a given chunk of binary data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L956-L961" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def process(self, data: ByteString) -&gt; Union[Optional[ByteString], Iterable[ByteString]]:
    &#34;&#34;&#34;
    This routine is overridden by children of `refinery.units.Unit` to define how
    the unit processes a given chunk of binary data.
    &#34;&#34;&#34;
    return data</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.log_warn"><code class="name flex">
<span>def <span class="ident">log_warn</span></span>(<span>self, *messages)</span>
</code></dt>
<dd>
<section class="desc"><p>Call <code><a title="refinery.units.Unit.output" href="#refinery.units.Unit.output">Unit.output()</a></code> for each provided message if and only if the
current log level is at least <code><a title="refinery.units.LogLevel.WARN" href="#refinery.units.LogLevel.WARN">LogLevel.WARN</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L963-L971" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_warn(self, *messages) -&gt; bool:
    &#34;&#34;&#34;
    Call `refinery.units.Unit.output` for each provided message if and only if the
    current log level is at least `refinery.units.LogLevel.WARN`.
    &#34;&#34;&#34;
    rv = self.log_level &gt;= LogLevel.WARN
    if rv and messages:
        self.output(*messages)
    return rv</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.log_info"><code class="name flex">
<span>def <span class="ident">log_info</span></span>(<span>self, *messages)</span>
</code></dt>
<dd>
<section class="desc"><p>Call <code><a title="refinery.units.Unit.output" href="#refinery.units.Unit.output">Unit.output()</a></code> for each provided message if and only if the
current log level is at least <code><a title="refinery.units.LogLevel.INFO" href="#refinery.units.LogLevel.INFO">LogLevel.INFO</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L973-L981" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_info(self, *messages) -&gt; bool:
    &#34;&#34;&#34;
    Call `refinery.units.Unit.output` for each provided message if and only if the
    current log level is at least `refinery.units.LogLevel.INFO`.
    &#34;&#34;&#34;
    rv = self.log_level &gt;= LogLevel.INFO
    if rv and messages:
        self.output(*messages)
    return rv</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.log_debug"><code class="name flex">
<span>def <span class="ident">log_debug</span></span>(<span>self, *messages)</span>
</code></dt>
<dd>
<section class="desc"><p>Call <code><a title="refinery.units.Unit.output" href="#refinery.units.Unit.output">Unit.output()</a></code> for each provided message if and only if the
current log level is at least <code><a title="refinery.units.LogLevel.DEBUG" href="#refinery.units.LogLevel.DEBUG">LogLevel.DEBUG</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L983-L991" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_debug(self, *messages) -&gt; bool:
    &#34;&#34;&#34;
    Call `refinery.units.Unit.output` for each provided message if and only if the
    current log level is at least `refinery.units.LogLevel.DEBUG`.
    &#34;&#34;&#34;
    rv = self.log_level &gt;= LogLevel.DEBUG
    if rv and messages:
        self.output(*messages)
    return rv</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.output"><code class="name flex">
<span>def <span class="ident">output</span></span>(<span>self, *messages)</span>
</code></dt>
<dd>
<section class="desc"><p>Logs the provided messages to stderr, prefixed with the current unit's name.
The routine accepts both string and byte type arguments. Bytestrings are
decoded with the default codec, using the 'backslashreplace' error handler.
Does not produce any output if the quiet switch has been enabled via the
command line arguments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L993-L1002" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def output(self, *messages) -&gt; None:
    &#34;&#34;&#34;
    Logs the provided messages to stderr, prefixed with the current unit&#39;s name.
    The routine accepts both string and byte type arguments. Bytestrings are
    decoded with the default codec, using the &#39;backslashreplace&#39; error handler.
    Does not produce any output if the quiet switch has been enabled via the
    command line arguments.
    &#34;&#34;&#34;
    if not self.args.quiet:
        return self._output(*messages)</code></pre>
</details>
</dd>
<dt id="refinery.units.Unit.detach"><code class="name flex">
<span>def <span class="ident">detach</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>When a unit is created using the <code><a title="refinery.units.Unit.assemble" href="#refinery.units.Unit.assemble">Unit.assemble()</a></code> method, it is attached to a
logger by default (in less abstract terms, the <code><a title="refinery.units.Unit.log_level" href="#refinery.units.Unit.log_level">Unit.log_level</a></code> property is
set to a positive value). This method detaches the unit from its logger, which also means that
any exceptions that occur during runtime will be raised to the caller.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/__init__.py#L1247-L1255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detach(self):
    &#34;&#34;&#34;
    When a unit is created using the `refinery.units.Unit.assemble` method, it is attached to a
    logger by default (in less abstract terms, the `refinery.units.Unit.log_level` property is
    set to a positive value). This method detaches the unit from its logger, which also means that
    any exceptions that occur during runtime will be raised to the caller.
    &#34;&#34;&#34;
    self.log_level = LogLevel.DETACHED
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery" href="../index.html">refinery</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="refinery.units.blockwise" href="blockwise/index.html">refinery.units.blockwise</a></code></li>
<li><code><a title="refinery.units.compression" href="compression/index.html">refinery.units.compression</a></code></li>
<li><code><a title="refinery.units.crypto" href="crypto/index.html">refinery.units.crypto</a></code></li>
<li><code><a title="refinery.units.encoding" href="encoding/index.html">refinery.units.encoding</a></code></li>
<li><code><a title="refinery.units.formats" href="formats/index.html">refinery.units.formats</a></code></li>
<li><code><a title="refinery.units.meta" href="meta/index.html">refinery.units.meta</a></code></li>
<li><code><a title="refinery.units.misc" href="misc/index.html">refinery.units.misc</a></code></li>
<li><code><a title="refinery.units.obfuscation" href="obfuscation/index.html">refinery.units.obfuscation</a></code></li>
<li><code><a title="refinery.units.pattern" href="pattern/index.html">refinery.units.pattern</a></code></li>
<li><code><a title="refinery.units.shortcuts" href="shortcuts/index.html">refinery.units.shortcuts</a></code></li>
<li><code><a title="refinery.units.sinks" href="sinks/index.html">refinery.units.sinks</a></code></li>
<li><code><a title="refinery.units.strings" href="strings/index.html">refinery.units.strings</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.ArgparseError" href="#refinery.units.ArgparseError">ArgparseError</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.RefineryPartialResult" href="#refinery.units.RefineryPartialResult">RefineryPartialResult</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.RefineryCriticalException" href="#refinery.units.RefineryCriticalException">RefineryCriticalException</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.Entry" href="#refinery.units.Entry">Entry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.Argument" href="#refinery.units.Argument">Argument</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.arg" href="#refinery.units.arg">arg</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.arg.switch" href="#refinery.units.arg.switch">switch</a></code></li>
<li><code><a title="refinery.units.arg.number" href="#refinery.units.arg.number">number</a></code></li>
<li><code><a title="refinery.units.arg.option" href="#refinery.units.arg.option">option</a></code></li>
<li><code><a title="refinery.units.arg.choice" href="#refinery.units.arg.choice">choice</a></code></li>
<li><code><a title="refinery.units.arg.infer" href="#refinery.units.arg.infer">infer</a></code></li>
<li><code><a title="refinery.units.arg.update_help" href="#refinery.units.arg.update_help">update_help</a></code></li>
<li><code><a title="refinery.units.arg.merge_args" href="#refinery.units.arg.merge_args">merge_args</a></code></li>
<li><code><a title="refinery.units.arg.merge_all" href="#refinery.units.arg.merge_all">merge_all</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.ArgumentSpecification" href="#refinery.units.ArgumentSpecification">ArgumentSpecification</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.ArgumentSpecification.merge" href="#refinery.units.ArgumentSpecification.merge">merge</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.Executable" href="#refinery.units.Executable">Executable</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.LogLevel" href="#refinery.units.LogLevel">LogLevel</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.DelayedArgumentProxy" href="#refinery.units.DelayedArgumentProxy">DelayedArgumentProxy</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.Unit" href="#refinery.units.Unit">Unit</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.Unit.argparser" href="#refinery.units.Unit.argparser">argparser</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="#refinery.units.Unit.superinit">superinit</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.filter" href="#refinery.units.Unit.filter">filter</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.process" href="#refinery.units.Unit.process">process</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.output" href="#refinery.units.Unit.output">output</a></code></li>
<li><code><a title="refinery.units.Unit.detach" href="#refinery.units.Unit.detach">detach</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>