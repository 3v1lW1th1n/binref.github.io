<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>the refinery.units.formats.pe.pemeta documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:12pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #EEEEEE}#index ul{padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #EEEEEE}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.pe.pemeta</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/formats/pe/pemeta.py#L0-L543" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import json

from functools import lru_cache
from contextlib import suppress
from pefile import PE, DIRECTORY_ENTRY, DEBUG_TYPE
from datetime import datetime, timezone
from asn1crypto import cms
from asn1crypto import x509

from ....lib.dotnet.header import DotNetHeader
from ... import arg, Unit


class pemeta(Unit):
    &#34;&#34;&#34;
    Extract metadata from PE files, including:

    - File version resource
    - Code signature information
    - Timestamps
    - If present, .NET header information
    &#34;&#34;&#34;
    def __init__(
        self, all : arg(&#39;-c&#39;, &#39;--custom&#39;,
            help=&#39;Unless enabled, everything will be extracted.&#39;) = True,
        debug      : arg(&#39;-D&#39;, help=&#39;Parse the PDB path from the debug directory.&#39;) = False,
        dotnet     : arg(&#39;-N&#39;, help=&#39;Parse the .NET header.&#39;) = False,
        signatures : arg(&#39;-S&#39;, help=&#39;Parse digital signatures.&#39;) = False,
        timestamps : arg(&#39;-T&#39;, help=&#39;Extract time stamps.&#39;) = False,
        version    : arg(&#39;-V&#39;, help=&#39;Parse the VERSION resource.&#39;) = False,
    ):
        super().__init__(
            debug=all or debug,
            dotnet=all or dotnet,
            signatures=all or signatures,
            timestamps=all or timestamps,
            version=all or version,
        )

    def _ensure_string(self, x):
        if not isinstance(x, str):
            x = repr(x) if not isinstance(x, bytes) else x.decode(self.codec, &#39;backslashreplace&#39;)
        return x

    def _parse_pedict(self, bin):
        return dict((
            self._ensure_string(key),
            self._ensure_string(val)
        ) for key, val in bin.items() if val)

    @lru_cache(maxsize=1, typed=False)
    def _getpe(self, data: bytearray) -&gt; PE:
        return PE(data=data, fast_load=True)

    def parse_signature(self, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human readable dictionary with information about
        time stamp and code signing certificates that are attached to the input PE file.
        &#34;&#34;&#34;
        from .pesig import pesig
        cert, info = pesig()(data), {}

        try:
            signature = cms.ContentInfo.load(cert)
        except Exception as E:
            raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

        def tscrawl(entry, native):
            with suppress(KeyError, TypeError):
                if entry[&#39;type&#39;] == &#39;signing_time&#39;:
                    return entry[&#39;values&#39;]
            try:
                keys = list(entry)
                assert all(isinstance(k, str) for k in keys)
            except Exception:
                try:
                    length = len(entry)
                except TypeError:
                    return None

                for k in range(length):
                    try:
                        item = entry[k]
                    except IndexError:
                        continue
                    results = tscrawl(item, native)
                    if results:
                        return results
            else:
                for key in keys:
                    value = entry[key]
                    results = tscrawl(value, native)
                    if isinstance(results, list) and len(results) == 1:
                        result = dict(Timestamp=str(results[0]))
                        with suppress(Exception):
                            acc = entry if native else entry.native
                            result[&#39;Timestamp Issuer&#39;] = acc[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;]
                        return result
                    elif results is not None:
                        return results

            with suppress(Exception):
                return tscrawl(entry.native, True)

        timestamps = []
        for signer in signature[&#39;content&#39;][&#39;signer_infos&#39;]:
            ts = tscrawl(signer, False)
            if ts is not None:
                timestamps.append(ts)
        if len(timestamps) == 1:
            info.update(timestamps[0])

        with suppress(Exception):
            for entry in signature[&#39;content&#39;][&#39;certificates&#39;]:
                cert = x509.Certificate.load(entry.dump())
                if cert.ca: continue
                tbs = cert.native[&#39;tbs_certificate&#39;]
                for extension in tbs[&#39;extensions&#39;]:
                    if extension[&#39;extn_id&#39;] == &#39;extended_key_usage&#39; and &#39;code_signing&#39; in extension[&#39;extn_value&#39;]:
                        Serial = F&#39;{tbs[&#34;serial_number&#34;]:x}&#39;
                        if len(Serial) % 2:
                            Serial = &#39;0&#39; + Serial
                        tbs = dict(
                            Issuer=tbs[&#39;issuer&#39;][&#39;common_name&#39;],
                            Subject=tbs[&#39;subject&#39;][&#39;common_name&#39;],
                            Serial=Serial,
                        )
                        info.update(tbs)
                        return info
        return info

    def parse_file_info(self, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human readable dictionary with information about
        the version resource of an input PE file, if available.
        &#34;&#34;&#34;
        try:
            pe = self._getpe(data)
            pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]])
            FileInfoList = pe.FileInfo
        except AttributeError:
            return None
        for FileInfo in FileInfoList:
            for FileInfoEntry in FileInfo:
                with suppress(AttributeError):
                    for StringTableEntry in FileInfoEntry.StringTable:
                        StringTableEntryParsed = self._parse_pedict(StringTableEntry.entries)
                        with suppress(AttributeError):
                            LangID = StringTableEntry.entries.get(&#39;LangID&#39;, None) or StringTableEntry.LangID
                            LangID = int(LangID, 0x10) if not isinstance(LangID, int) else LangID
                            LangHi = LangID &gt;&gt; 0x10
                            LangLo = LangID &amp; 0xFFFF
                            Language = self._LCID.get(LangHi, &#39;Language Neutral&#39;)
                            Charset = self._CHARSET.get(LangLo, &#39;Unknown Charset&#39;)
                            StringTableEntryParsed.update(
                                LangID=F&#39;{LangID:08X}&#39;,
                                Charset=Charset,
                                Language=Language
                            )
                        return StringTableEntryParsed

    def parse_time_stamps(self, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts time stamps from the PE header (link time), as well as from the imports,
        exports, debug, and resource directory. The resource time stamp is also parsed as
        a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
        &#34;&#34;&#34;
        def dt(ts):
            # parse as UTC but then forget time zone information
            return datetime.fromtimestamp(ts, tz=timezone.utc).replace(tzinfo=None)

        pe = self._getpe(data)
        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]
        ])

        info = {}

        with suppress(AttributeError):
            info.update(Linker=dt(pe.FILE_HEADER.TimeDateStamp))

        with suppress(AttributeError):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                info.update(Import=dt(entry.TimeDateStamp()))

        with suppress(AttributeError):
            for entry in pe.DIRECTORY_ENTRY_DEBUG:
                info.update(DbgDir=dt(entry.struct.TimeDateStamp))

        with suppress(AttributeError):
            Export = pe.DIRECTORY_ENTRY_EXPORT.struct.TimeDateStamp
            if Export: info.update(Export=dt(Export))

        with suppress(AttributeError):
            res_timestamp = pe.DIRECTORY_ENTRY_RESOURCE.struct.TimeDateStamp
            if res_timestamp:
                with suppress(ValueError):
                    from ...misc.datefix import datefix
                    dos = datefix.dostime(res_timestamp)
                    info.update(Delphi=dos)
                    info.update(RsrcTS=dt(res_timestamp))

        return {key: str(value) for key, value in info.items()}

    def parse_dotnet(self, data):
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human readable dictionary with information about
        the .NET metadata of an input PE file.
        &#34;&#34;&#34;
        header = DotNetHeader(data, pe=self._getpe(data))
        tables = header.meta.Streams.Tables
        info = dict(
            RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
            Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
            VersionString=header.meta.VersionString
        )

        if len(tables.Assembly) == 1:
            assembly = tables.Assembly[0]
            info.update(
                AssemblyName=assembly.Name,
                Release=&#39;{}.{}.{}.{}&#39;.format(
                    assembly.MajorVersion,
                    assembly.MinorVersion,
                    assembly.BuildNumber,
                    assembly.RevisionNumber
                )
            )

        if len(tables.Module) == 1:
            module = tables.Module[0]
            info.update(ModuleName=module.Name)

        return info

    def parse_debug_data(self, data):
        result = {}
        pe = self._getpe(data)
        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;]])
        for dbg in pe.DIRECTORY_ENTRY_DEBUG:
            if DEBUG_TYPE.get(dbg.struct.Type, None) != &#39;IMAGE_DEBUG_TYPE_CODEVIEW&#39;:
                continue
            with suppress(Exception):
                pdb = dbg.entry.PdbFileName
                if 0 in pdb:
                    pdb = pdb[:pdb.index(0)]
                result.update(
                    PdbPath=pdb.decode(self.codec),
                    PdbAge=dbg.entry.Age
                )
        return result

    def process(self, data):
        result = {}

        if self.args.version:
            try:
                file_info = self.parse_file_info(data)
            except Exception as E:
                self.log_info(F&#39;failed to obtain file info resource: {E!s}&#39;)
            else:
                if file_info:
                    result[&#39;FileInfo&#39;] = file_info
        if self.args.dotnet:
            try:
                dnet_info = self.parse_dotnet(data)
            except Exception as E:
                self.log_info(F&#39;failed to obtain .NET information: {E!s}&#39;)
            else:
                if dnet_info:
                    result[&#39;DotNet&#39;] = dnet_info
        if self.args.debug:
            try:
                debug_info = self.parse_debug_data(data)
            except Exception as E:
                self.log_info(F&#39;failed to parse debug directory: {E!s}&#39;)
            else:
                if debug_info:
                    result[&#39;Debug&#39;] = debug_info

        signature = {}

        if self.args.timestamps or self.args.signatures:
            with suppress(Exception):
                signature = self.parse_signature(data)

        if self.args.timestamps:
            ts = self.parse_time_stamps(data)
            with suppress(KeyError):
                ts.update(Signed=signature[&#39;Timestamp&#39;])
            result.update(TimeStamp=ts)

        if signature and self.args.signatures:
            result[&#39;Signature&#39;] = signature

        return json.dumps(result, indent=4, ensure_ascii=False).encode(self.codec)

    _LCID = {
        0x0436: &#39;Afrikaans-South Africa&#39;,
        0x041c: &#39;Albanian-Albania&#39;,
        0x045e: &#39;Amharic-Ethiopia&#39;,
        0x0401: &#39;Arabic (Saudi Arabia)&#39;,
        0x1401: &#39;Arabic (Algeria)&#39;,
        0x3c01: &#39;Arabic (Bahrain)&#39;,
        0x0c01: &#39;Arabic (Egypt)&#39;,
        0x0801: &#39;Arabic (Iraq)&#39;,
        0x2c01: &#39;Arabic (Jordan)&#39;,
        0x3401: &#39;Arabic (Kuwait)&#39;,
        0x3001: &#39;Arabic (Lebanon)&#39;,
        0x1001: &#39;Arabic (Libya)&#39;,
        0x1801: &#39;Arabic (Morocco)&#39;,
        0x2001: &#39;Arabic (Oman)&#39;,
        0x4001: &#39;Arabic (Qatar)&#39;,
        0x2801: &#39;Arabic (Syria)&#39;,
        0x1c01: &#39;Arabic (Tunisia)&#39;,
        0x3801: &#39;Arabic (U.A.E.)&#39;,
        0x2401: &#39;Arabic (Yemen)&#39;,
        0x042b: &#39;Armenian-Armenia&#39;,
        0x044d: &#39;Assamese&#39;,
        0x082c: &#39;Azeri (Cyrillic)&#39;,
        0x042c: &#39;Azeri (Latin)&#39;,
        0x042d: &#39;Basque&#39;,
        0x0423: &#39;Belarusian&#39;,
        0x0445: &#39;Bengali (India)&#39;,
        0x0845: &#39;Bengali (Bangladesh)&#39;,
        0x141A: &#39;Bosnian (Bosnia/Herzegovina)&#39;,
        0x0402: &#39;Bulgarian&#39;,
        0x0455: &#39;Burmese&#39;,
        0x0403: &#39;Catalan&#39;,
        0x045c: &#39;Cherokee-United States&#39;,
        0x0804: &#39;Chinese (People\&#39;s Republic of China)&#39;,
        0x1004: &#39;Chinese (Singapore)&#39;,
        0x0404: &#39;Chinese (Taiwan)&#39;,
        0x0c04: &#39;Chinese (Hong Kong SAR)&#39;,
        0x1404: &#39;Chinese (Macao SAR)&#39;,
        0x041a: &#39;Croatian&#39;,
        0x101a: &#39;Croatian (Bosnia/Herzegovina)&#39;,
        0x0405: &#39;Czech&#39;,
        0x0406: &#39;Danish&#39;,
        0x0465: &#39;Divehi&#39;,
        0x0413: &#39;Dutch-Netherlands&#39;,
        0x0813: &#39;Dutch-Belgium&#39;,
        0x0466: &#39;Edo&#39;,
        0x0409: &#39;English (United States)&#39;,
        0x0809: &#39;English (United Kingdom)&#39;,
        0x0c09: &#39;English (Australia)&#39;,
        0x2809: &#39;English (Belize)&#39;,
        0x1009: &#39;English (Canada)&#39;,
        0x2409: &#39;English (Caribbean)&#39;,
        0x3c09: &#39;English (Hong Kong SAR)&#39;,
        0x4009: &#39;English (India)&#39;,
        0x3809: &#39;English (Indonesia)&#39;,
        0x1809: &#39;English (Ireland)&#39;,
        0x2009: &#39;English (Jamaica)&#39;,
        0x4409: &#39;English (Malaysia)&#39;,
        0x1409: &#39;English (New Zealand)&#39;,
        0x3409: &#39;English (Philippines)&#39;,
        0x4809: &#39;English (Singapore)&#39;,
        0x1c09: &#39;English (South Africa)&#39;,
        0x2c09: &#39;English (Trinidad)&#39;,
        0x3009: &#39;English (Zimbabwe)&#39;,
        0x0425: &#39;Estonian&#39;,
        0x0438: &#39;Faroese&#39;,
        0x0429: &#39;Farsi&#39;,
        0x0464: &#39;Filipino&#39;,
        0x040b: &#39;Finnish&#39;,
        0x040c: &#39;French (France)&#39;,
        0x080c: &#39;French (Belgium)&#39;,
        0x2c0c: &#39;French (Cameroon)&#39;,
        0x0c0c: &#39;French (Canada)&#39;,
        0x240c: &#39;French (Democratic Rep. of Congo)&#39;,
        0x300c: &#39;French (Cote d\&#39;Ivoire)&#39;,
        0x3c0c: &#39;French (Haiti)&#39;,
        0x140c: &#39;French (Luxembourg)&#39;,
        0x340c: &#39;French (Mali)&#39;,
        0x180c: &#39;French (Monaco)&#39;,
        0x380c: &#39;French (Morocco)&#39;,
        0xe40c: &#39;French (North Africa)&#39;,
        0x200c: &#39;French (Reunion)&#39;,
        0x280c: &#39;French (Senegal)&#39;,
        0x100c: &#39;French (Switzerland)&#39;,
        0x1c0c: &#39;French (West Indies)&#39;,
        0x0462: &#39;Frisian-Netherlands&#39;,
        0x0467: &#39;Fulfulde-Nigeria&#39;,
        0x042f: &#39;FYRO Macedonian&#39;,
        0x083c: &#39;Gaelic (Ireland)&#39;,
        0x043c: &#39;Gaelic (Scotland)&#39;,
        0x0456: &#39;Galician&#39;,
        0x0437: &#39;Georgian&#39;,
        0x0407: &#39;German (Germany)&#39;,
        0x0c07: &#39;German (Austria)&#39;,
        0x1407: &#39;German (Liechtenstein)&#39;,
        0x1007: &#39;German (Luxembourg)&#39;,
        0x0807: &#39;German (Switzerland)&#39;,
        0x0408: &#39;Greek&#39;,
        0x0474: &#39;Guarani-Paraguay&#39;,
        0x0447: &#39;Gujarati&#39;,
        0x0468: &#39;Hausa-Nigeria&#39;,
        0x0475: &#39;Hawaiian (United States)&#39;,
        0x040d: &#39;Hebrew&#39;,
        0x0439: &#39;Hindi&#39;,
        0x040e: &#39;Hungarian&#39;,
        0x0469: &#39;Ibibio-Nigeria&#39;,
        0x040f: &#39;Icelandic&#39;,
        0x0470: &#39;Igbo-Nigeria&#39;,
        0x0421: &#39;Indonesian&#39;,
        0x045d: &#39;Inuktitut&#39;,
        0x0410: &#39;Italian (Italy)&#39;,
        0x0810: &#39;Italian (Switzerland)&#39;,
        0x0411: &#39;Japanese&#39;,
        0x044b: &#39;Kannada&#39;,
        0x0471: &#39;Kanuri-Nigeria&#39;,
        0x0860: &#39;Kashmiri&#39;,
        0x0460: &#39;Kashmiri (Arabic)&#39;,
        0x043f: &#39;Kazakh&#39;,
        0x0453: &#39;Khmer&#39;,
        0x0457: &#39;Konkani&#39;,
        0x0412: &#39;Korean&#39;,
        0x0440: &#39;Kyrgyz (Cyrillic)&#39;,
        0x0454: &#39;Lao&#39;,
        0x0476: &#39;Latin&#39;,
        0x0426: &#39;Latvian&#39;,
        0x0427: &#39;Lithuanian&#39;,
        0x043e: &#39;Malay-Malaysia&#39;,
        0x083e: &#39;Malay-Brunei Darussalam&#39;,
        0x044c: &#39;Malayalam&#39;,
        0x043a: &#39;Maltese&#39;,
        0x0458: &#39;Manipuri&#39;,
        0x0481: &#39;Maori-New Zealand&#39;,
        0x044e: &#39;Marathi&#39;,
        0x0450: &#39;Mongolian (Cyrillic)&#39;,
        0x0850: &#39;Mongolian (Mongolian)&#39;,
        0x0461: &#39;Nepali&#39;,
        0x0861: &#39;Nepali-India&#39;,
        0x0414: &#39;Norwegian (Bokmål)&#39;,
        0x0814: &#39;Norwegian (Nynorsk)&#39;,
        0x0448: &#39;Oriya&#39;,
        0x0472: &#39;Oromo&#39;,
        0x0479: &#39;Papiamentu&#39;,
        0x0463: &#39;Pashto&#39;,
        0x0415: &#39;Polish&#39;,
        0x0416: &#39;Portuguese-Brazil&#39;,
        0x0816: &#39;Portuguese-Portugal&#39;,
        0x0446: &#39;Punjabi&#39;,
        0x0846: &#39;Punjabi (Pakistan)&#39;,
        0x046B: &#39;Quecha (Bolivia)&#39;,
        0x086B: &#39;Quecha (Ecuador)&#39;,
        0x0C6B: &#39;Quecha (Peru)&#39;,
        0x0417: &#39;Rhaeto-Romanic&#39;,
        0x0418: &#39;Romanian&#39;,
        0x0818: &#39;Romanian (Moldava)&#39;,
        0x0419: &#39;Russian&#39;,
        0x0819: &#39;Russian (Moldava)&#39;,
        0x043b: &#39;Sami (Lappish)&#39;,
        0x044f: &#39;Sanskrit&#39;,
        0x046c: &#39;Sepedi&#39;,
        0x0c1a: &#39;Serbian (Cyrillic)&#39;,
        0x081a: &#39;Serbian (Latin)&#39;,
        0x0459: &#39;Sindhi (India)&#39;,
        0x0859: &#39;Sindhi (Pakistan)&#39;,
        0x045b: &#39;Sinhalese-Sri Lanka&#39;,
        0x041b: &#39;Slovak&#39;,
        0x0424: &#39;Slovenian&#39;,
        0x0477: &#39;Somali&#39;,
        0x042e: &#39;Sorbian&#39;,
        0x0c0a: &#39;Spanish (Modern Sort)&#39;,
        0x040a: &#39;Spanish (Traditional Sort)&#39;,
        0x2c0a: &#39;Spanish (Argentina)&#39;,
        0x400a: &#39;Spanish (Bolivia)&#39;,
        0x340a: &#39;Spanish (Chile)&#39;,
        0x240a: &#39;Spanish (Colombia)&#39;,
        0x140a: &#39;Spanish (Costa Rica)&#39;,
        0x1c0a: &#39;Spanish (Dominican Republic)&#39;,
        0x300a: &#39;Spanish (Ecuador)&#39;,
        0x440a: &#39;Spanish (El Salvador)&#39;,
        0x100a: &#39;Spanish (Guatemala)&#39;,
        0x480a: &#39;Spanish (Honduras)&#39;,
        0x580a: &#39;Spanish (Latin America)&#39;,
        0x080a: &#39;Spanish (Mexico)&#39;,
        0x4c0a: &#39;Spanish (Nicaragua)&#39;,
        0x180a: &#39;Spanish (Panama)&#39;,
        0x3c0a: &#39;Spanish (Paraguay)&#39;,
        0x280a: &#39;Spanish (Peru)&#39;,
        0x500a: &#39;Spanish (Puerto Rico)&#39;,
        0x540a: &#39;Spanish (United States)&#39;,
        0x380a: &#39;Spanish (Uruguay)&#39;,
        0x200a: &#39;Spanish (Venezuela)&#39;,
        0x0430: &#39;Sutu&#39;,
        0x0441: &#39;Swahili&#39;,
        0x041d: &#39;Swedish&#39;,
        0x081d: &#39;Swedish-Finland&#39;,
        0x045a: &#39;Syriac&#39;,
        0x0428: &#39;Tajik&#39;,
        0x045f: &#39;Tamazight (Arabic)&#39;,
        0x085f: &#39;Tamazight (Latin)&#39;,
        0x0449: &#39;Tamil&#39;,
        0x0444: &#39;Tatar&#39;,
        0x044a: &#39;Telugu&#39;,
        0x041e: &#39;Thai&#39;,
        0x0851: &#39;Tibetan (Bhutan)&#39;,
        0x0451: &#39;Tibetan (People\&#39;s Republic of China)&#39;,
        0x0873: &#39;Tigrigna (Eritrea)&#39;,
        0x0473: &#39;Tigrigna (Ethiopia)&#39;,
        0x0431: &#39;Tsonga&#39;,
        0x0432: &#39;Tswana&#39;,
        0x041f: &#39;Turkish&#39;,
        0x0442: &#39;Turkmen&#39;,
        0x0480: &#39;Uighur-China&#39;,
        0x0422: &#39;Ukrainian&#39;,
        0x0420: &#39;Urdu&#39;,
        0x0820: &#39;Urdu-India&#39;,
        0x0843: &#39;Uzbek (Cyrillic)&#39;,
        0x0443: &#39;Uzbek (Latin)&#39;,
        0x0433: &#39;Venda&#39;,
        0x042a: &#39;Vietnamese&#39;,
        0x0452: &#39;Welsh&#39;,
        0x0434: &#39;Xhosa&#39;,
        0x0478: &#39;Yi&#39;,
        0x043d: &#39;Yiddish&#39;,
        0x046a: &#39;Yoruba&#39;,
        0x0435: &#39;Zulu&#39;,
        0x04ff: &#39;HID (Human Interface Device)&#39;
    }

    _CHARSET = {
        0x0000: &#39;7-bit ASCII&#39;,
        0x03A4: &#39;Japan (Shift ? JIS X-0208)&#39;,
        0x03B5: &#39;Korea (Shift ? KSC 5601)&#39;,
        0x03B6: &#39;Taiwan (Big5)&#39;,
        0x04B0: &#39;Unicode&#39;,
        0x04E2: &#39;Latin-2 (Eastern European)&#39;,
        0x04E3: &#39;Cyrillic&#39;,
        0x04E4: &#39;Multilingual&#39;,
        0x04E5: &#39;Greek&#39;,
        0x04E6: &#39;Turkish&#39;,
        0x04E7: &#39;Hebrew&#39;,
        0x04E8: &#39;Arabic&#39;,
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta"><code class="flex name class">
<span>class <span class="ident">pemeta</span></span>
<span>(</span><span>all=True, debug=False, dotnet=False, signatures=False, timestamps=False, version=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract metadata from PE files, including:</p>
<ul>
<li>File version resource</li>
<li>Code signature information</li>
<li>Timestamps</li>
<li>If present, .NET header information</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/formats/pe/pemeta.py#L16-L544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class pemeta(Unit):
    &#34;&#34;&#34;
    Extract metadata from PE files, including:

    - File version resource
    - Code signature information
    - Timestamps
    - If present, .NET header information
    &#34;&#34;&#34;
    def __init__(
        self, all : arg(&#39;-c&#39;, &#39;--custom&#39;,
            help=&#39;Unless enabled, everything will be extracted.&#39;) = True,
        debug      : arg(&#39;-D&#39;, help=&#39;Parse the PDB path from the debug directory.&#39;) = False,
        dotnet     : arg(&#39;-N&#39;, help=&#39;Parse the .NET header.&#39;) = False,
        signatures : arg(&#39;-S&#39;, help=&#39;Parse digital signatures.&#39;) = False,
        timestamps : arg(&#39;-T&#39;, help=&#39;Extract time stamps.&#39;) = False,
        version    : arg(&#39;-V&#39;, help=&#39;Parse the VERSION resource.&#39;) = False,
    ):
        super().__init__(
            debug=all or debug,
            dotnet=all or dotnet,
            signatures=all or signatures,
            timestamps=all or timestamps,
            version=all or version,
        )

    def _ensure_string(self, x):
        if not isinstance(x, str):
            x = repr(x) if not isinstance(x, bytes) else x.decode(self.codec, &#39;backslashreplace&#39;)
        return x

    def _parse_pedict(self, bin):
        return dict((
            self._ensure_string(key),
            self._ensure_string(val)
        ) for key, val in bin.items() if val)

    @lru_cache(maxsize=1, typed=False)
    def _getpe(self, data: bytearray) -&gt; PE:
        return PE(data=data, fast_load=True)

    def parse_signature(self, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human readable dictionary with information about
        time stamp and code signing certificates that are attached to the input PE file.
        &#34;&#34;&#34;
        from .pesig import pesig
        cert, info = pesig()(data), {}

        try:
            signature = cms.ContentInfo.load(cert)
        except Exception as E:
            raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

        def tscrawl(entry, native):
            with suppress(KeyError, TypeError):
                if entry[&#39;type&#39;] == &#39;signing_time&#39;:
                    return entry[&#39;values&#39;]
            try:
                keys = list(entry)
                assert all(isinstance(k, str) for k in keys)
            except Exception:
                try:
                    length = len(entry)
                except TypeError:
                    return None

                for k in range(length):
                    try:
                        item = entry[k]
                    except IndexError:
                        continue
                    results = tscrawl(item, native)
                    if results:
                        return results
            else:
                for key in keys:
                    value = entry[key]
                    results = tscrawl(value, native)
                    if isinstance(results, list) and len(results) == 1:
                        result = dict(Timestamp=str(results[0]))
                        with suppress(Exception):
                            acc = entry if native else entry.native
                            result[&#39;Timestamp Issuer&#39;] = acc[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;]
                        return result
                    elif results is not None:
                        return results

            with suppress(Exception):
                return tscrawl(entry.native, True)

        timestamps = []
        for signer in signature[&#39;content&#39;][&#39;signer_infos&#39;]:
            ts = tscrawl(signer, False)
            if ts is not None:
                timestamps.append(ts)
        if len(timestamps) == 1:
            info.update(timestamps[0])

        with suppress(Exception):
            for entry in signature[&#39;content&#39;][&#39;certificates&#39;]:
                cert = x509.Certificate.load(entry.dump())
                if cert.ca: continue
                tbs = cert.native[&#39;tbs_certificate&#39;]
                for extension in tbs[&#39;extensions&#39;]:
                    if extension[&#39;extn_id&#39;] == &#39;extended_key_usage&#39; and &#39;code_signing&#39; in extension[&#39;extn_value&#39;]:
                        Serial = F&#39;{tbs[&#34;serial_number&#34;]:x}&#39;
                        if len(Serial) % 2:
                            Serial = &#39;0&#39; + Serial
                        tbs = dict(
                            Issuer=tbs[&#39;issuer&#39;][&#39;common_name&#39;],
                            Subject=tbs[&#39;subject&#39;][&#39;common_name&#39;],
                            Serial=Serial,
                        )
                        info.update(tbs)
                        return info
        return info

    def parse_file_info(self, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human readable dictionary with information about
        the version resource of an input PE file, if available.
        &#34;&#34;&#34;
        try:
            pe = self._getpe(data)
            pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]])
            FileInfoList = pe.FileInfo
        except AttributeError:
            return None
        for FileInfo in FileInfoList:
            for FileInfoEntry in FileInfo:
                with suppress(AttributeError):
                    for StringTableEntry in FileInfoEntry.StringTable:
                        StringTableEntryParsed = self._parse_pedict(StringTableEntry.entries)
                        with suppress(AttributeError):
                            LangID = StringTableEntry.entries.get(&#39;LangID&#39;, None) or StringTableEntry.LangID
                            LangID = int(LangID, 0x10) if not isinstance(LangID, int) else LangID
                            LangHi = LangID &gt;&gt; 0x10
                            LangLo = LangID &amp; 0xFFFF
                            Language = self._LCID.get(LangHi, &#39;Language Neutral&#39;)
                            Charset = self._CHARSET.get(LangLo, &#39;Unknown Charset&#39;)
                            StringTableEntryParsed.update(
                                LangID=F&#39;{LangID:08X}&#39;,
                                Charset=Charset,
                                Language=Language
                            )
                        return StringTableEntryParsed

    def parse_time_stamps(self, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts time stamps from the PE header (link time), as well as from the imports,
        exports, debug, and resource directory. The resource time stamp is also parsed as
        a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
        &#34;&#34;&#34;
        def dt(ts):
            # parse as UTC but then forget time zone information
            return datetime.fromtimestamp(ts, tz=timezone.utc).replace(tzinfo=None)

        pe = self._getpe(data)
        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;],
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]
        ])

        info = {}

        with suppress(AttributeError):
            info.update(Linker=dt(pe.FILE_HEADER.TimeDateStamp))

        with suppress(AttributeError):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                info.update(Import=dt(entry.TimeDateStamp()))

        with suppress(AttributeError):
            for entry in pe.DIRECTORY_ENTRY_DEBUG:
                info.update(DbgDir=dt(entry.struct.TimeDateStamp))

        with suppress(AttributeError):
            Export = pe.DIRECTORY_ENTRY_EXPORT.struct.TimeDateStamp
            if Export: info.update(Export=dt(Export))

        with suppress(AttributeError):
            res_timestamp = pe.DIRECTORY_ENTRY_RESOURCE.struct.TimeDateStamp
            if res_timestamp:
                with suppress(ValueError):
                    from ...misc.datefix import datefix
                    dos = datefix.dostime(res_timestamp)
                    info.update(Delphi=dos)
                    info.update(RsrcTS=dt(res_timestamp))

        return {key: str(value) for key, value in info.items()}

    def parse_dotnet(self, data):
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human readable dictionary with information about
        the .NET metadata of an input PE file.
        &#34;&#34;&#34;
        header = DotNetHeader(data, pe=self._getpe(data))
        tables = header.meta.Streams.Tables
        info = dict(
            RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
            Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
            VersionString=header.meta.VersionString
        )

        if len(tables.Assembly) == 1:
            assembly = tables.Assembly[0]
            info.update(
                AssemblyName=assembly.Name,
                Release=&#39;{}.{}.{}.{}&#39;.format(
                    assembly.MajorVersion,
                    assembly.MinorVersion,
                    assembly.BuildNumber,
                    assembly.RevisionNumber
                )
            )

        if len(tables.Module) == 1:
            module = tables.Module[0]
            info.update(ModuleName=module.Name)

        return info

    def parse_debug_data(self, data):
        result = {}
        pe = self._getpe(data)
        pe.parse_data_directories(directories=[
            DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;]])
        for dbg in pe.DIRECTORY_ENTRY_DEBUG:
            if DEBUG_TYPE.get(dbg.struct.Type, None) != &#39;IMAGE_DEBUG_TYPE_CODEVIEW&#39;:
                continue
            with suppress(Exception):
                pdb = dbg.entry.PdbFileName
                if 0 in pdb:
                    pdb = pdb[:pdb.index(0)]
                result.update(
                    PdbPath=pdb.decode(self.codec),
                    PdbAge=dbg.entry.Age
                )
        return result

    def process(self, data):
        result = {}

        if self.args.version:
            try:
                file_info = self.parse_file_info(data)
            except Exception as E:
                self.log_info(F&#39;failed to obtain file info resource: {E!s}&#39;)
            else:
                if file_info:
                    result[&#39;FileInfo&#39;] = file_info
        if self.args.dotnet:
            try:
                dnet_info = self.parse_dotnet(data)
            except Exception as E:
                self.log_info(F&#39;failed to obtain .NET information: {E!s}&#39;)
            else:
                if dnet_info:
                    result[&#39;DotNet&#39;] = dnet_info
        if self.args.debug:
            try:
                debug_info = self.parse_debug_data(data)
            except Exception as E:
                self.log_info(F&#39;failed to parse debug directory: {E!s}&#39;)
            else:
                if debug_info:
                    result[&#39;Debug&#39;] = debug_info

        signature = {}

        if self.args.timestamps or self.args.signatures:
            with suppress(Exception):
                signature = self.parse_signature(data)

        if self.args.timestamps:
            ts = self.parse_time_stamps(data)
            with suppress(KeyError):
                ts.update(Signed=signature[&#39;Timestamp&#39;])
            result.update(TimeStamp=ts)

        if signature and self.args.signatures:
            result[&#39;Signature&#39;] = signature

        return json.dumps(result, indent=4, ensure_ascii=False).encode(self.codec)

    _LCID = {
        0x0436: &#39;Afrikaans-South Africa&#39;,
        0x041c: &#39;Albanian-Albania&#39;,
        0x045e: &#39;Amharic-Ethiopia&#39;,
        0x0401: &#39;Arabic (Saudi Arabia)&#39;,
        0x1401: &#39;Arabic (Algeria)&#39;,
        0x3c01: &#39;Arabic (Bahrain)&#39;,
        0x0c01: &#39;Arabic (Egypt)&#39;,
        0x0801: &#39;Arabic (Iraq)&#39;,
        0x2c01: &#39;Arabic (Jordan)&#39;,
        0x3401: &#39;Arabic (Kuwait)&#39;,
        0x3001: &#39;Arabic (Lebanon)&#39;,
        0x1001: &#39;Arabic (Libya)&#39;,
        0x1801: &#39;Arabic (Morocco)&#39;,
        0x2001: &#39;Arabic (Oman)&#39;,
        0x4001: &#39;Arabic (Qatar)&#39;,
        0x2801: &#39;Arabic (Syria)&#39;,
        0x1c01: &#39;Arabic (Tunisia)&#39;,
        0x3801: &#39;Arabic (U.A.E.)&#39;,
        0x2401: &#39;Arabic (Yemen)&#39;,
        0x042b: &#39;Armenian-Armenia&#39;,
        0x044d: &#39;Assamese&#39;,
        0x082c: &#39;Azeri (Cyrillic)&#39;,
        0x042c: &#39;Azeri (Latin)&#39;,
        0x042d: &#39;Basque&#39;,
        0x0423: &#39;Belarusian&#39;,
        0x0445: &#39;Bengali (India)&#39;,
        0x0845: &#39;Bengali (Bangladesh)&#39;,
        0x141A: &#39;Bosnian (Bosnia/Herzegovina)&#39;,
        0x0402: &#39;Bulgarian&#39;,
        0x0455: &#39;Burmese&#39;,
        0x0403: &#39;Catalan&#39;,
        0x045c: &#39;Cherokee-United States&#39;,
        0x0804: &#39;Chinese (People\&#39;s Republic of China)&#39;,
        0x1004: &#39;Chinese (Singapore)&#39;,
        0x0404: &#39;Chinese (Taiwan)&#39;,
        0x0c04: &#39;Chinese (Hong Kong SAR)&#39;,
        0x1404: &#39;Chinese (Macao SAR)&#39;,
        0x041a: &#39;Croatian&#39;,
        0x101a: &#39;Croatian (Bosnia/Herzegovina)&#39;,
        0x0405: &#39;Czech&#39;,
        0x0406: &#39;Danish&#39;,
        0x0465: &#39;Divehi&#39;,
        0x0413: &#39;Dutch-Netherlands&#39;,
        0x0813: &#39;Dutch-Belgium&#39;,
        0x0466: &#39;Edo&#39;,
        0x0409: &#39;English (United States)&#39;,
        0x0809: &#39;English (United Kingdom)&#39;,
        0x0c09: &#39;English (Australia)&#39;,
        0x2809: &#39;English (Belize)&#39;,
        0x1009: &#39;English (Canada)&#39;,
        0x2409: &#39;English (Caribbean)&#39;,
        0x3c09: &#39;English (Hong Kong SAR)&#39;,
        0x4009: &#39;English (India)&#39;,
        0x3809: &#39;English (Indonesia)&#39;,
        0x1809: &#39;English (Ireland)&#39;,
        0x2009: &#39;English (Jamaica)&#39;,
        0x4409: &#39;English (Malaysia)&#39;,
        0x1409: &#39;English (New Zealand)&#39;,
        0x3409: &#39;English (Philippines)&#39;,
        0x4809: &#39;English (Singapore)&#39;,
        0x1c09: &#39;English (South Africa)&#39;,
        0x2c09: &#39;English (Trinidad)&#39;,
        0x3009: &#39;English (Zimbabwe)&#39;,
        0x0425: &#39;Estonian&#39;,
        0x0438: &#39;Faroese&#39;,
        0x0429: &#39;Farsi&#39;,
        0x0464: &#39;Filipino&#39;,
        0x040b: &#39;Finnish&#39;,
        0x040c: &#39;French (France)&#39;,
        0x080c: &#39;French (Belgium)&#39;,
        0x2c0c: &#39;French (Cameroon)&#39;,
        0x0c0c: &#39;French (Canada)&#39;,
        0x240c: &#39;French (Democratic Rep. of Congo)&#39;,
        0x300c: &#39;French (Cote d\&#39;Ivoire)&#39;,
        0x3c0c: &#39;French (Haiti)&#39;,
        0x140c: &#39;French (Luxembourg)&#39;,
        0x340c: &#39;French (Mali)&#39;,
        0x180c: &#39;French (Monaco)&#39;,
        0x380c: &#39;French (Morocco)&#39;,
        0xe40c: &#39;French (North Africa)&#39;,
        0x200c: &#39;French (Reunion)&#39;,
        0x280c: &#39;French (Senegal)&#39;,
        0x100c: &#39;French (Switzerland)&#39;,
        0x1c0c: &#39;French (West Indies)&#39;,
        0x0462: &#39;Frisian-Netherlands&#39;,
        0x0467: &#39;Fulfulde-Nigeria&#39;,
        0x042f: &#39;FYRO Macedonian&#39;,
        0x083c: &#39;Gaelic (Ireland)&#39;,
        0x043c: &#39;Gaelic (Scotland)&#39;,
        0x0456: &#39;Galician&#39;,
        0x0437: &#39;Georgian&#39;,
        0x0407: &#39;German (Germany)&#39;,
        0x0c07: &#39;German (Austria)&#39;,
        0x1407: &#39;German (Liechtenstein)&#39;,
        0x1007: &#39;German (Luxembourg)&#39;,
        0x0807: &#39;German (Switzerland)&#39;,
        0x0408: &#39;Greek&#39;,
        0x0474: &#39;Guarani-Paraguay&#39;,
        0x0447: &#39;Gujarati&#39;,
        0x0468: &#39;Hausa-Nigeria&#39;,
        0x0475: &#39;Hawaiian (United States)&#39;,
        0x040d: &#39;Hebrew&#39;,
        0x0439: &#39;Hindi&#39;,
        0x040e: &#39;Hungarian&#39;,
        0x0469: &#39;Ibibio-Nigeria&#39;,
        0x040f: &#39;Icelandic&#39;,
        0x0470: &#39;Igbo-Nigeria&#39;,
        0x0421: &#39;Indonesian&#39;,
        0x045d: &#39;Inuktitut&#39;,
        0x0410: &#39;Italian (Italy)&#39;,
        0x0810: &#39;Italian (Switzerland)&#39;,
        0x0411: &#39;Japanese&#39;,
        0x044b: &#39;Kannada&#39;,
        0x0471: &#39;Kanuri-Nigeria&#39;,
        0x0860: &#39;Kashmiri&#39;,
        0x0460: &#39;Kashmiri (Arabic)&#39;,
        0x043f: &#39;Kazakh&#39;,
        0x0453: &#39;Khmer&#39;,
        0x0457: &#39;Konkani&#39;,
        0x0412: &#39;Korean&#39;,
        0x0440: &#39;Kyrgyz (Cyrillic)&#39;,
        0x0454: &#39;Lao&#39;,
        0x0476: &#39;Latin&#39;,
        0x0426: &#39;Latvian&#39;,
        0x0427: &#39;Lithuanian&#39;,
        0x043e: &#39;Malay-Malaysia&#39;,
        0x083e: &#39;Malay-Brunei Darussalam&#39;,
        0x044c: &#39;Malayalam&#39;,
        0x043a: &#39;Maltese&#39;,
        0x0458: &#39;Manipuri&#39;,
        0x0481: &#39;Maori-New Zealand&#39;,
        0x044e: &#39;Marathi&#39;,
        0x0450: &#39;Mongolian (Cyrillic)&#39;,
        0x0850: &#39;Mongolian (Mongolian)&#39;,
        0x0461: &#39;Nepali&#39;,
        0x0861: &#39;Nepali-India&#39;,
        0x0414: &#39;Norwegian (Bokmål)&#39;,
        0x0814: &#39;Norwegian (Nynorsk)&#39;,
        0x0448: &#39;Oriya&#39;,
        0x0472: &#39;Oromo&#39;,
        0x0479: &#39;Papiamentu&#39;,
        0x0463: &#39;Pashto&#39;,
        0x0415: &#39;Polish&#39;,
        0x0416: &#39;Portuguese-Brazil&#39;,
        0x0816: &#39;Portuguese-Portugal&#39;,
        0x0446: &#39;Punjabi&#39;,
        0x0846: &#39;Punjabi (Pakistan)&#39;,
        0x046B: &#39;Quecha (Bolivia)&#39;,
        0x086B: &#39;Quecha (Ecuador)&#39;,
        0x0C6B: &#39;Quecha (Peru)&#39;,
        0x0417: &#39;Rhaeto-Romanic&#39;,
        0x0418: &#39;Romanian&#39;,
        0x0818: &#39;Romanian (Moldava)&#39;,
        0x0419: &#39;Russian&#39;,
        0x0819: &#39;Russian (Moldava)&#39;,
        0x043b: &#39;Sami (Lappish)&#39;,
        0x044f: &#39;Sanskrit&#39;,
        0x046c: &#39;Sepedi&#39;,
        0x0c1a: &#39;Serbian (Cyrillic)&#39;,
        0x081a: &#39;Serbian (Latin)&#39;,
        0x0459: &#39;Sindhi (India)&#39;,
        0x0859: &#39;Sindhi (Pakistan)&#39;,
        0x045b: &#39;Sinhalese-Sri Lanka&#39;,
        0x041b: &#39;Slovak&#39;,
        0x0424: &#39;Slovenian&#39;,
        0x0477: &#39;Somali&#39;,
        0x042e: &#39;Sorbian&#39;,
        0x0c0a: &#39;Spanish (Modern Sort)&#39;,
        0x040a: &#39;Spanish (Traditional Sort)&#39;,
        0x2c0a: &#39;Spanish (Argentina)&#39;,
        0x400a: &#39;Spanish (Bolivia)&#39;,
        0x340a: &#39;Spanish (Chile)&#39;,
        0x240a: &#39;Spanish (Colombia)&#39;,
        0x140a: &#39;Spanish (Costa Rica)&#39;,
        0x1c0a: &#39;Spanish (Dominican Republic)&#39;,
        0x300a: &#39;Spanish (Ecuador)&#39;,
        0x440a: &#39;Spanish (El Salvador)&#39;,
        0x100a: &#39;Spanish (Guatemala)&#39;,
        0x480a: &#39;Spanish (Honduras)&#39;,
        0x580a: &#39;Spanish (Latin America)&#39;,
        0x080a: &#39;Spanish (Mexico)&#39;,
        0x4c0a: &#39;Spanish (Nicaragua)&#39;,
        0x180a: &#39;Spanish (Panama)&#39;,
        0x3c0a: &#39;Spanish (Paraguay)&#39;,
        0x280a: &#39;Spanish (Peru)&#39;,
        0x500a: &#39;Spanish (Puerto Rico)&#39;,
        0x540a: &#39;Spanish (United States)&#39;,
        0x380a: &#39;Spanish (Uruguay)&#39;,
        0x200a: &#39;Spanish (Venezuela)&#39;,
        0x0430: &#39;Sutu&#39;,
        0x0441: &#39;Swahili&#39;,
        0x041d: &#39;Swedish&#39;,
        0x081d: &#39;Swedish-Finland&#39;,
        0x045a: &#39;Syriac&#39;,
        0x0428: &#39;Tajik&#39;,
        0x045f: &#39;Tamazight (Arabic)&#39;,
        0x085f: &#39;Tamazight (Latin)&#39;,
        0x0449: &#39;Tamil&#39;,
        0x0444: &#39;Tatar&#39;,
        0x044a: &#39;Telugu&#39;,
        0x041e: &#39;Thai&#39;,
        0x0851: &#39;Tibetan (Bhutan)&#39;,
        0x0451: &#39;Tibetan (People\&#39;s Republic of China)&#39;,
        0x0873: &#39;Tigrigna (Eritrea)&#39;,
        0x0473: &#39;Tigrigna (Ethiopia)&#39;,
        0x0431: &#39;Tsonga&#39;,
        0x0432: &#39;Tswana&#39;,
        0x041f: &#39;Turkish&#39;,
        0x0442: &#39;Turkmen&#39;,
        0x0480: &#39;Uighur-China&#39;,
        0x0422: &#39;Ukrainian&#39;,
        0x0420: &#39;Urdu&#39;,
        0x0820: &#39;Urdu-India&#39;,
        0x0843: &#39;Uzbek (Cyrillic)&#39;,
        0x0443: &#39;Uzbek (Latin)&#39;,
        0x0433: &#39;Venda&#39;,
        0x042a: &#39;Vietnamese&#39;,
        0x0452: &#39;Welsh&#39;,
        0x0434: &#39;Xhosa&#39;,
        0x0478: &#39;Yi&#39;,
        0x043d: &#39;Yiddish&#39;,
        0x046a: &#39;Yoruba&#39;,
        0x0435: &#39;Zulu&#39;,
        0x04ff: &#39;HID (Human Interface Device)&#39;
    }

    _CHARSET = {
        0x0000: &#39;7-bit ASCII&#39;,
        0x03A4: &#39;Japan (Shift ? JIS X-0208)&#39;,
        0x03B5: &#39;Korea (Shift ? KSC 5601)&#39;,
        0x03B6: &#39;Taiwan (Big5)&#39;,
        0x04B0: &#39;Unicode&#39;,
        0x04E2: &#39;Latin-2 (Eastern European)&#39;,
        0x04E3: &#39;Cyrillic&#39;,
        0x04E4: &#39;Multilingual&#39;,
        0x04E5: &#39;Greek&#39;,
        0x04E6: &#39;Turkish&#39;,
        0x04E7: &#39;Hebrew&#39;,
        0x04E8: &#39;Arabic&#39;,
    }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.argspec"><code class="name">var <span class="ident">argspec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_signature"><code class="name flex">
<span>def <span class="ident">parse_signature</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human readable dictionary with information about
time stamp and code signing certificates that are attached to the input PE file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/formats/pe/pemeta.py#L57-L132" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_signature(self, data: bytearray) -&gt; dict:
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human readable dictionary with information about
    time stamp and code signing certificates that are attached to the input PE file.
    &#34;&#34;&#34;
    from .pesig import pesig
    cert, info = pesig()(data), {}

    try:
        signature = cms.ContentInfo.load(cert)
    except Exception as E:
        raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

    def tscrawl(entry, native):
        with suppress(KeyError, TypeError):
            if entry[&#39;type&#39;] == &#39;signing_time&#39;:
                return entry[&#39;values&#39;]
        try:
            keys = list(entry)
            assert all(isinstance(k, str) for k in keys)
        except Exception:
            try:
                length = len(entry)
            except TypeError:
                return None

            for k in range(length):
                try:
                    item = entry[k]
                except IndexError:
                    continue
                results = tscrawl(item, native)
                if results:
                    return results
        else:
            for key in keys:
                value = entry[key]
                results = tscrawl(value, native)
                if isinstance(results, list) and len(results) == 1:
                    result = dict(Timestamp=str(results[0]))
                    with suppress(Exception):
                        acc = entry if native else entry.native
                        result[&#39;Timestamp Issuer&#39;] = acc[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;]
                    return result
                elif results is not None:
                    return results

        with suppress(Exception):
            return tscrawl(entry.native, True)

    timestamps = []
    for signer in signature[&#39;content&#39;][&#39;signer_infos&#39;]:
        ts = tscrawl(signer, False)
        if ts is not None:
            timestamps.append(ts)
    if len(timestamps) == 1:
        info.update(timestamps[0])

    with suppress(Exception):
        for entry in signature[&#39;content&#39;][&#39;certificates&#39;]:
            cert = x509.Certificate.load(entry.dump())
            if cert.ca: continue
            tbs = cert.native[&#39;tbs_certificate&#39;]
            for extension in tbs[&#39;extensions&#39;]:
                if extension[&#39;extn_id&#39;] == &#39;extended_key_usage&#39; and &#39;code_signing&#39; in extension[&#39;extn_value&#39;]:
                    Serial = F&#39;{tbs[&#34;serial_number&#34;]:x}&#39;
                    if len(Serial) % 2:
                        Serial = &#39;0&#39; + Serial
                    tbs = dict(
                        Issuer=tbs[&#39;issuer&#39;][&#39;common_name&#39;],
                        Subject=tbs[&#39;subject&#39;][&#39;common_name&#39;],
                        Serial=Serial,
                    )
                    info.update(tbs)
                    return info
    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_file_info"><code class="name flex">
<span>def <span class="ident">parse_file_info</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human readable dictionary with information about
the version resource of an input PE file, if available.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/formats/pe/pemeta.py#L134-L162" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_file_info(self, data: bytearray) -&gt; dict:
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human readable dictionary with information about
    the version resource of an input PE file, if available.
    &#34;&#34;&#34;
    try:
        pe = self._getpe(data)
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]])
        FileInfoList = pe.FileInfo
    except AttributeError:
        return None
    for FileInfo in FileInfoList:
        for FileInfoEntry in FileInfo:
            with suppress(AttributeError):
                for StringTableEntry in FileInfoEntry.StringTable:
                    StringTableEntryParsed = self._parse_pedict(StringTableEntry.entries)
                    with suppress(AttributeError):
                        LangID = StringTableEntry.entries.get(&#39;LangID&#39;, None) or StringTableEntry.LangID
                        LangID = int(LangID, 0x10) if not isinstance(LangID, int) else LangID
                        LangHi = LangID &gt;&gt; 0x10
                        LangLo = LangID &amp; 0xFFFF
                        Language = self._LCID.get(LangHi, &#39;Language Neutral&#39;)
                        Charset = self._CHARSET.get(LangLo, &#39;Unknown Charset&#39;)
                        StringTableEntryParsed.update(
                            LangID=F&#39;{LangID:08X}&#39;,
                            Charset=Charset,
                            Language=Language
                        )
                    return StringTableEntryParsed</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps"><code class="name flex">
<span>def <span class="ident">parse_time_stamps</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts time stamps from the PE header (link time), as well as from the imports,
exports, debug, and resource directory. The resource time stamp is also parsed as
a DOS time stamp and returned as the "Delphi" time stamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/formats/pe/pemeta.py#L164-L208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_time_stamps(self, data: bytearray) -&gt; dict:
    &#34;&#34;&#34;
    Extracts time stamps from the PE header (link time), as well as from the imports,
    exports, debug, and resource directory. The resource time stamp is also parsed as
    a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
    &#34;&#34;&#34;
    def dt(ts):
        # parse as UTC but then forget time zone information
        return datetime.fromtimestamp(ts, tz=timezone.utc).replace(tzinfo=None)

    pe = self._getpe(data)
    pe.parse_data_directories(directories=[
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_IMPORT&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;],
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_RESOURCE&#39;]
    ])

    info = {}

    with suppress(AttributeError):
        info.update(Linker=dt(pe.FILE_HEADER.TimeDateStamp))

    with suppress(AttributeError):
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            info.update(Import=dt(entry.TimeDateStamp()))

    with suppress(AttributeError):
        for entry in pe.DIRECTORY_ENTRY_DEBUG:
            info.update(DbgDir=dt(entry.struct.TimeDateStamp))

    with suppress(AttributeError):
        Export = pe.DIRECTORY_ENTRY_EXPORT.struct.TimeDateStamp
        if Export: info.update(Export=dt(Export))

    with suppress(AttributeError):
        res_timestamp = pe.DIRECTORY_ENTRY_RESOURCE.struct.TimeDateStamp
        if res_timestamp:
            with suppress(ValueError):
                from ...misc.datefix import datefix
                dos = datefix.dostime(res_timestamp)
                info.update(Delphi=dos)
                info.update(RsrcTS=dt(res_timestamp))

    return {key: str(value) for key, value in info.items()}</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_dotnet"><code class="name flex">
<span>def <span class="ident">parse_dotnet</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human readable dictionary with information about
the .NET metadata of an input PE file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/formats/pe/pemeta.py#L210-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_dotnet(self, data):
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human readable dictionary with information about
    the .NET metadata of an input PE file.
    &#34;&#34;&#34;
    header = DotNetHeader(data, pe=self._getpe(data))
    tables = header.meta.Streams.Tables
    info = dict(
        RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
        Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
        VersionString=header.meta.VersionString
    )

    if len(tables.Assembly) == 1:
        assembly = tables.Assembly[0]
        info.update(
            AssemblyName=assembly.Name,
            Release=&#39;{}.{}.{}.{}&#39;.format(
                assembly.MajorVersion,
                assembly.MinorVersion,
                assembly.BuildNumber,
                assembly.RevisionNumber
            )
        )

    if len(tables.Module) == 1:
        module = tables.Module[0]
        info.update(ModuleName=module.Name)

    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_debug_data"><code class="name flex">
<span>def <span class="ident">parse_debug_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/formats/pe/pemeta.py#L241-L257" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_debug_data(self, data):
    result = {}
    pe = self._getpe(data)
    pe.parse_data_directories(directories=[
        DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_DEBUG&#39;]])
    for dbg in pe.DIRECTORY_ENTRY_DEBUG:
        if DEBUG_TYPE.get(dbg.struct.Type, None) != &#39;IMAGE_DEBUG_TYPE_CODEVIEW&#39;:
            continue
        with suppress(Exception):
            pdb = dbg.entry.PdbFileName
            if 0 in pdb:
                pdb = pdb[:pdb.index(0)]
            result.update(
                PdbPath=pdb.decode(self.codec),
                PdbAge=dbg.entry.Age
            )
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.detach" href="../../index.html#refinery.units.Unit.detach">detach</a></code></li>
<li><code><a title="refinery.units.Unit.filter" href="../../index.html#refinery.units.Unit.filter">filter</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.output" href="../../index.html#refinery.units.Unit.output">output</a></code></li>
<li><code><a title="refinery.units.Unit.process" href="../../index.html#refinery.units.Unit.process">process</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.pe" href="index.html">refinery.units.formats.pe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.pemeta" href="#refinery.units.formats.pe.pemeta.pemeta">pemeta</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_signature" href="#refinery.units.formats.pe.pemeta.pemeta.parse_signature">parse_signature</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_file_info" href="#refinery.units.formats.pe.pemeta.pemeta.parse_file_info">parse_file_info</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps" href="#refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps">parse_time_stamps</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_dotnet" href="#refinery.units.formats.pe.pemeta.pemeta.parse_dotnet">parse_dotnet</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_debug_data" href="#refinery.units.formats.pe.pemeta.pemeta.parse_debug_data">parse_debug_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>