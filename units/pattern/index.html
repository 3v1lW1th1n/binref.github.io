<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>the refinery.units.pattern documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:12pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #EEEEEE}#index ul{padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #EEEEEE}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.pattern</code></h1>
</header>
<section id="section-intro">
<p>Pattern matching based extraction and substitution units.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L0-L286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Pattern matching based extraction and substitution units.
&#34;&#34;&#34;
import re

from typing import Iterable, Optional, Callable, Union, ByteString, Dict
from itertools import islice
from hashlib import blake2b

from ...lib.types import INF, AST
from ...lib.argformats import regexp
from .. import arg, Unit


def _lazy_load(cmd: bytes):
    from ...lib.loader import load_commandline
    return load_commandline(cmd.decode(&#39;UTF8&#39;))


def TransformSubstitutionFactory(fmt):
    &#34;&#34;&#34;
    Produces a substitution callable for `refinery.resub` and `refinery.rex`.

    This substitution callable supports refinery operations to be applied to
    match groups. The format `fmt` can contain expressions of the form `$0`,
    `$1`, etc. to be substituted by the corresponding match group from the
    regular expression. Additionally, more complex expressions are supported
    which allow application of arbitrary refinery units to the match group.
    For example, the expression
    ```
    $(1 | hex | add 0x12 | gz)
    ```
    takes the match group with index 1, hex decodes it, adds the value `0x12`
    to every byte and then decompresses it using gzip. To escape a dollar
    symbol, prefix it with an additional dollar symbol.

    Expressions can be nested: For example, `$(1 | snip :$2)` would assume
    that the second match group is an integer k and return only the first k
    bytes of the first match group.
    &#34;&#34;&#34;

    def unescape_dollars(s):
        return re.sub(RB&#39;(\$+)\$&#39;, lambda m: m[1], s)

    class PipeLine:
        def __init__(self, argument, seam, pipeline):
            if not argument.isdigit():
                raise ValueError(F&#39;argument &#34;{argument}&#34; is not a digit!&#39;)

            def parse_pipeline():
                for command in pipeline:
                    unit = TransformSubstitutionFactory(command)
                    if type(unit) == bytes:
                        unit = _lazy_load(unit)
                    yield unit

            self.argument = int(argument, 10)
            self.seam = unescape_dollars(seam)
            self.units = list(parse_pipeline())

        def __call__(self, match):
            data = match.group(self.argument)
            for unit in self.units:
                try:
                    data = unit(data)
                except AttributeError:
                    unit = _lazy_load(unit(match))
                    data = unit(data)
            return self.seam + data

    try:
        fmt = fmt.decode(&#39;UNICODE_ESCAPE&#39;)
    except AttributeError:
        if not isinstance(fmt, str):
            raise

    fmt = fmt.encode(&#39;UTF8&#39;)
    escapes = {m.start() + 1 for m in re.finditer(BR&#39;\$\$&#39;, fmt)}
    processors = []
    offset = stop = 0
    pattern = re.compile(BR&#39;\$(\d+|\(\d+)&#39;)

    while True:
        expression = pattern.search(fmt, stop)
        if not expression:
            break
        start, stop = expression.span()
        if start in escapes:
            continue
        argument = expression[1]
        if not argument.isdigit():
            level = 1
            poles = [expression.start() + 2]
            while level &gt; 0:
                if stop &gt; len(fmt):
                    raise ValueError(F&#39;unbalanced parentheses at {stop} for expression: {fmt}&#39;)
                if fmt[stop:stop + 1] == B&#39;(&#39;:
                    level += 1
                if fmt[stop:stop + 1] == B&#39;)&#39;:
                    level -= 1
                if fmt[stop:stop + 1] == B&#39;|&#39; and level == 1:
                    poles.append(stop + 1)
                stop += 1

            poles.append(stop)
            pipeline = [
                fmt[a:b - 1].decode(&#39;UTF8&#39;).strip()
                for a, b in zip(poles, poles[1:])
            ]

            argument = pipeline.pop(0)
        else:
            pipeline = []

        processors.append(PipeLine(
            argument,
            fmt[offset:start],
            pipeline
        ))
        offset = stop

    epilog = unescape_dollars(fmt[offset:])

    if not offset:
        transformation = epilog
    else:
        def transformation(match):
            return B&#39;&#39;.join(p(match) for p in processors) + epilog

    return transformation


class PatternExtractorBase(Unit, abstract=True):

    def __init__(
        self,
        min        : arg.number(&#39;-n&#39;, help=&#39;Matches must have length at least N.&#39;) = 1,
        max        : arg.number(&#39;-N&#39;, help=&#39;Matches must have length at most N.&#39;) = None,
        len        : arg.number(&#39;-E&#39;, help=&#39;Matches must be of length N.&#39;) = None,
        stripspace : arg.switch(&#39;-S&#39;, help=&#39;Strip all whitespace from input data.&#39;) = False,
        unique     : arg.switch(&#39;-q&#39;, help=&#39;Yield every (transformed) Match only once.&#39;) = False,
        longest    : arg.switch(&#39;-l&#39;, help=&#39;Sort results by length.&#39;) = False,
        take       : arg.number(&#39;-t&#39;, help=&#39;Return only the first N occurrences in order of appearance.&#39;) = None,
    ):
        super().__init__(
            min=min,
            max=max or INF,
            len=len or AST,
            stripspace=stripspace,
            unique=unique,
            ascii=True,
            utf16=True,
            longest=longest,
            take=take or INF
        )

    def matches(self, data: ByteString, pattern: Union[ByteString, re.Pattern]):
        &#34;&#34;&#34;
        Searches the input data for the given regular expression pattern. If the
        argument `utf16` is `True`, search for occurrences where a zero byte
        is between every character of the match. The `ascii` option allows to
        control whether normal matching results are also returned.
        &#34;&#34;&#34;
        if not isinstance(pattern, re.Pattern):
            pattern = re.compile(pattern)
        if self.args.ascii:
            yield from pattern.finditer(data)
        if self.args.utf16:
            for zm in re.findall(BR&#39;(?:.\0)+&#39;, data):
                for match in pattern.finditer(zm[::2]):
                    yield match

    def _prefilter(self, matches: Iterable[re.Match]) -&gt; Iterable[re.Match]:
        barrier = set()
        taken = 0
        for match in matches:
            hit = memoryview(match[0])
            if not hit or len(hit) != self.args.len or len(hit) &lt; self.args.min or len(hit) &gt; self.args.max:
                continue
            if self.args.unique:
                uid = int.from_bytes(blake2b(hit, digest_size=8).digest(), &#39;big&#39;)
                if uid in barrier:
                    continue
                barrier.add(uid)
            yield match
            taken += 1
            if not self.args.longest and taken &gt;= self.args.take:
                break

    def _postfilter(self, matches: Iterable[re.Match]) -&gt; Iterable[re.Match]:
        result = matches
        if self.args.longest and self.args.take and self.args.take is not INF:
            try:
                length = len(result)
            except TypeError:
                result = list(result)
                length = len(result)
            indices = sorted(range(length), key=lambda k: len(result[k][0]), reverse=True)
            for k in sorted(islice(indices, abs(self.args.take))):
                yield result[k]
        elif self.args.longest:
            yield from sorted(result, key=len, reverse=True)
        elif self.args.take:
            yield from islice(result, abs(self.args.take))

    def matchfilter(self, matches: Iterable[re.Match]) -&gt; Iterable[re.Match]:
        yield from self._postfilter(self._prefilter(matches))

    def matches_filtered(
        self,
        data: ByteString,
        pattern: Union[ByteString, re.Pattern],
        *transforms: Optional[Iterable[Callable[[re.Match], Optional[Union[Dict, ByteString]]]]]
    ) -&gt; Iterable[Union[Dict, ByteString]]:
        &#34;&#34;&#34;
        This is a wrapper for `AbstractRegexUint.matches` which filters the
        results according to the given commandline arguments. Returns a
        dictionary mapping its position (start, end) in the input data to the
        filtered and transformed match that was found at this position.
        &#34;&#34;&#34;
        def funcify(t):
            def const(m): return t
            return t if callable(t) else const

        transforms = [funcify(f) for f in transforms] or [lambda m: m[0]]

        if self.args.stripspace:
            data = re.sub(BR&#39;\s+&#39;, B&#39;&#39;, data)
        for match in self.matchfilter(self.matches(memoryview(data), pattern)):
            for transform in transforms:
                t = transform(match)
                if t is not None: yield t


class PatternExtractor(PatternExtractorBase, abstract=True):
    def __init__(
        self, min=1, max=None, len=None, stripspace=False, unique=False, longest=False, take=None,
        ascii: arg.switch(&#39;-u&#39;, &#39;--no-ascii&#39;, group=&#39;AvsU&#39;, help=&#39;Search for UTF16 encoded patterns only.&#39;) = True,
        utf16: arg.switch(&#39;-a&#39;, &#39;--no-utf16&#39;, group=&#39;AvsU&#39;, help=&#39;Search for ASCII encoded patterns only.&#39;) = True,
    ):
        super().__init__(
            min=min,
            max=max,
            len=len,
            stripspace=stripspace,
            unique=unique,
            longest=longest,
            take=take
        )
        self.args.ascii = ascii
        self.args.utf16 = utf16


class RegexUnit(PatternExtractorBase, abstract=True):

    def __init__(
        self, regex : arg(type=regexp, help=&#39;Regular expression to match.&#39;),
        # TODO: Use positional only in Python 3.8
        # /,
        multiline   : arg.switch(&#39;-M&#39;, help=&#39;Caret and dollar match the beginning and end of &#39;
                                            &#39;a line, a dot does not match line breaks.&#39;) = False,
        ignorecase  : arg.switch(&#39;-I&#39;, help=&#39;Ignore capitalization for alphabetic characters.&#39;) = False,
        utf16       : arg.switch(&#39;-u&#39;, help=&#39;Search for unicode patterns instead of ascii.&#39;) = False,
        min=1, max=None, len=None, stripspace=False, unique=False, longest=False, take=None
    ):
        super().__init__(
            min=min,
            max=max,
            len=len,
            stripspace=stripspace,
            unique=unique,
            longest=longest,
            take=take
        )

        self.args.utf16 = utf16
        self.args.ascii = not utf16

        regex_flags = B&#39;m&#39; if multiline else B&#39;s&#39;
        if ignorecase: regex_flags += B&#39;i&#39;

        if isinstance(regex, str):
            regex = regex.encode(self.codec)

        self.args.regex = B&#39;(?%s)%s&#39; % (regex_flags, regex)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="refinery.units.pattern.carve" href="carve.html">refinery.units.pattern.carve</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.carve_json" href="carve_json.html">refinery.units.pattern.carve_json</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.carve_pe" href="carve_pe.html">refinery.units.pattern.carve_pe</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.carve_xml" href="carve_xml.html">refinery.units.pattern.carve_xml</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.carve_zip" href="carve_zip.html">refinery.units.pattern.carve_zip</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.defang" href="defang.html">refinery.units.pattern.defang</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.dnsdomain" href="dnsdomain.html">refinery.units.pattern.dnsdomain</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.mimewords" href="mimewords.html">refinery.units.pattern.mimewords</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.resplit" href="resplit.html">refinery.units.pattern.resplit</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.resub" href="resub.html">refinery.units.pattern.resub</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.rex" href="rex.html">refinery.units.pattern.rex</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.urlguards" href="urlguards.html">refinery.units.pattern.urlguards</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.pattern.xtp" href="xtp.html">refinery.units.pattern.xtp</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.pattern.TransformSubstitutionFactory"><code class="name flex">
<span>def <span class="ident">TransformSubstitutionFactory</span></span>(<span>fmt)</span>
</code></dt>
<dd>
<section class="desc"><p>Produces a substitution callable for <code><a title="refinery.resub" href="../../index.html#refinery.resub">resub</a></code> and <code><a title="refinery.rex" href="../../index.html#refinery.rex">rex</a></code>.</p>
<p>This substitution callable supports refinery operations to be applied to
match groups. The format <code>fmt</code> can contain expressions of the form <code>$0</code>,
<code>$1</code>, etc. to be substituted by the corresponding match group from the
regular expression. Additionally, more complex expressions are supported
which allow application of arbitrary refinery units to the match group.
For example, the expression</p>
<pre><code>$(1 | hex | add 0x12 | gz)
</code></pre>
<p>takes the match group with index 1, hex decodes it, adds the value <code>0x12</code>
to every byte and then decompresses it using gzip. To escape a dollar
symbol, prefix it with an additional dollar symbol.</p>
<p>Expressions can be nested: For example, <code>$(1 | snip :$2)</code> would assume
that the second match group is an integer k and return only the first k
bytes of the first match group.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L22-L132" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def TransformSubstitutionFactory(fmt):
    &#34;&#34;&#34;
    Produces a substitution callable for `refinery.resub` and `refinery.rex`.

    This substitution callable supports refinery operations to be applied to
    match groups. The format `fmt` can contain expressions of the form `$0`,
    `$1`, etc. to be substituted by the corresponding match group from the
    regular expression. Additionally, more complex expressions are supported
    which allow application of arbitrary refinery units to the match group.
    For example, the expression
    ```
    $(1 | hex | add 0x12 | gz)
    ```
    takes the match group with index 1, hex decodes it, adds the value `0x12`
    to every byte and then decompresses it using gzip. To escape a dollar
    symbol, prefix it with an additional dollar symbol.

    Expressions can be nested: For example, `$(1 | snip :$2)` would assume
    that the second match group is an integer k and return only the first k
    bytes of the first match group.
    &#34;&#34;&#34;

    def unescape_dollars(s):
        return re.sub(RB&#39;(\$+)\$&#39;, lambda m: m[1], s)

    class PipeLine:
        def __init__(self, argument, seam, pipeline):
            if not argument.isdigit():
                raise ValueError(F&#39;argument &#34;{argument}&#34; is not a digit!&#39;)

            def parse_pipeline():
                for command in pipeline:
                    unit = TransformSubstitutionFactory(command)
                    if type(unit) == bytes:
                        unit = _lazy_load(unit)
                    yield unit

            self.argument = int(argument, 10)
            self.seam = unescape_dollars(seam)
            self.units = list(parse_pipeline())

        def __call__(self, match):
            data = match.group(self.argument)
            for unit in self.units:
                try:
                    data = unit(data)
                except AttributeError:
                    unit = _lazy_load(unit(match))
                    data = unit(data)
            return self.seam + data

    try:
        fmt = fmt.decode(&#39;UNICODE_ESCAPE&#39;)
    except AttributeError:
        if not isinstance(fmt, str):
            raise

    fmt = fmt.encode(&#39;UTF8&#39;)
    escapes = {m.start() + 1 for m in re.finditer(BR&#39;\$\$&#39;, fmt)}
    processors = []
    offset = stop = 0
    pattern = re.compile(BR&#39;\$(\d+|\(\d+)&#39;)

    while True:
        expression = pattern.search(fmt, stop)
        if not expression:
            break
        start, stop = expression.span()
        if start in escapes:
            continue
        argument = expression[1]
        if not argument.isdigit():
            level = 1
            poles = [expression.start() + 2]
            while level &gt; 0:
                if stop &gt; len(fmt):
                    raise ValueError(F&#39;unbalanced parentheses at {stop} for expression: {fmt}&#39;)
                if fmt[stop:stop + 1] == B&#39;(&#39;:
                    level += 1
                if fmt[stop:stop + 1] == B&#39;)&#39;:
                    level -= 1
                if fmt[stop:stop + 1] == B&#39;|&#39; and level == 1:
                    poles.append(stop + 1)
                stop += 1

            poles.append(stop)
            pipeline = [
                fmt[a:b - 1].decode(&#39;UTF8&#39;).strip()
                for a, b in zip(poles, poles[1:])
            ]

            argument = pipeline.pop(0)
        else:
            pipeline = []

        processors.append(PipeLine(
            argument,
            fmt[offset:start],
            pipeline
        ))
        offset = stop

    epilog = unescape_dollars(fmt[offset:])

    if not offset:
        transformation = epilog
    else:
        def transformation(match):
            return B&#39;&#39;.join(p(match) for p in processors) + epilog

    return transformation</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.pattern.PatternExtractorBase"><code class="flex name class">
<span>class <span class="ident">PatternExtractorBase</span></span>
<span>(</span><span>min=1, max=None, len=None, stripspace=False, unique=False, longest=False, take=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L135-L234" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PatternExtractorBase(Unit, abstract=True):

    def __init__(
        self,
        min        : arg.number(&#39;-n&#39;, help=&#39;Matches must have length at least N.&#39;) = 1,
        max        : arg.number(&#39;-N&#39;, help=&#39;Matches must have length at most N.&#39;) = None,
        len        : arg.number(&#39;-E&#39;, help=&#39;Matches must be of length N.&#39;) = None,
        stripspace : arg.switch(&#39;-S&#39;, help=&#39;Strip all whitespace from input data.&#39;) = False,
        unique     : arg.switch(&#39;-q&#39;, help=&#39;Yield every (transformed) Match only once.&#39;) = False,
        longest    : arg.switch(&#39;-l&#39;, help=&#39;Sort results by length.&#39;) = False,
        take       : arg.number(&#39;-t&#39;, help=&#39;Return only the first N occurrences in order of appearance.&#39;) = None,
    ):
        super().__init__(
            min=min,
            max=max or INF,
            len=len or AST,
            stripspace=stripspace,
            unique=unique,
            ascii=True,
            utf16=True,
            longest=longest,
            take=take or INF
        )

    def matches(self, data: ByteString, pattern: Union[ByteString, re.Pattern]):
        &#34;&#34;&#34;
        Searches the input data for the given regular expression pattern. If the
        argument `utf16` is `True`, search for occurrences where a zero byte
        is between every character of the match. The `ascii` option allows to
        control whether normal matching results are also returned.
        &#34;&#34;&#34;
        if not isinstance(pattern, re.Pattern):
            pattern = re.compile(pattern)
        if self.args.ascii:
            yield from pattern.finditer(data)
        if self.args.utf16:
            for zm in re.findall(BR&#39;(?:.\0)+&#39;, data):
                for match in pattern.finditer(zm[::2]):
                    yield match

    def _prefilter(self, matches: Iterable[re.Match]) -&gt; Iterable[re.Match]:
        barrier = set()
        taken = 0
        for match in matches:
            hit = memoryview(match[0])
            if not hit or len(hit) != self.args.len or len(hit) &lt; self.args.min or len(hit) &gt; self.args.max:
                continue
            if self.args.unique:
                uid = int.from_bytes(blake2b(hit, digest_size=8).digest(), &#39;big&#39;)
                if uid in barrier:
                    continue
                barrier.add(uid)
            yield match
            taken += 1
            if not self.args.longest and taken &gt;= self.args.take:
                break

    def _postfilter(self, matches: Iterable[re.Match]) -&gt; Iterable[re.Match]:
        result = matches
        if self.args.longest and self.args.take and self.args.take is not INF:
            try:
                length = len(result)
            except TypeError:
                result = list(result)
                length = len(result)
            indices = sorted(range(length), key=lambda k: len(result[k][0]), reverse=True)
            for k in sorted(islice(indices, abs(self.args.take))):
                yield result[k]
        elif self.args.longest:
            yield from sorted(result, key=len, reverse=True)
        elif self.args.take:
            yield from islice(result, abs(self.args.take))

    def matchfilter(self, matches: Iterable[re.Match]) -&gt; Iterable[re.Match]:
        yield from self._postfilter(self._prefilter(matches))

    def matches_filtered(
        self,
        data: ByteString,
        pattern: Union[ByteString, re.Pattern],
        *transforms: Optional[Iterable[Callable[[re.Match], Optional[Union[Dict, ByteString]]]]]
    ) -&gt; Iterable[Union[Dict, ByteString]]:
        &#34;&#34;&#34;
        This is a wrapper for `AbstractRegexUint.matches` which filters the
        results according to the given commandline arguments. Returns a
        dictionary mapping its position (start, end) in the input data to the
        filtered and transformed match that was found at this position.
        &#34;&#34;&#34;
        def funcify(t):
            def const(m): return t
            return t if callable(t) else const

        transforms = [funcify(f) for f in transforms] or [lambda m: m[0]]

        if self.args.stripspace:
            data = re.sub(BR&#39;\s+&#39;, B&#39;&#39;, data)
        for match in self.matchfilter(self.matches(memoryview(data), pattern)):
            for transform in transforms:
                t = transform(match)
                if t is not None: yield t</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.PatternExtractor" href="#refinery.units.pattern.PatternExtractor">PatternExtractor</a></li>
<li><a title="refinery.units.pattern.RegexUnit" href="#refinery.units.pattern.RegexUnit">RegexUnit</a></li>
<li><a title="refinery.units.pattern.dnsdomain.dnsdomain" href="dnsdomain.html#refinery.units.pattern.dnsdomain.dnsdomain">dnsdomain</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.pattern.PatternExtractorBase.argspec"><code class="name">var <span class="ident">argspec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.pattern.PatternExtractorBase.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>self, data, pattern)</span>
</code></dt>
<dd>
<section class="desc"><p>Searches the input data for the given regular expression pattern. If the
argument <code>utf16</code> is <code>True</code>, search for occurrences where a zero byte
is between every character of the match. The <code>ascii</code> option allows to
control whether normal matching results are also returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L159-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matches(self, data: ByteString, pattern: Union[ByteString, re.Pattern]):
    &#34;&#34;&#34;
    Searches the input data for the given regular expression pattern. If the
    argument `utf16` is `True`, search for occurrences where a zero byte
    is between every character of the match. The `ascii` option allows to
    control whether normal matching results are also returned.
    &#34;&#34;&#34;
    if not isinstance(pattern, re.Pattern):
        pattern = re.compile(pattern)
    if self.args.ascii:
        yield from pattern.finditer(data)
    if self.args.utf16:
        for zm in re.findall(BR&#39;(?:.\0)+&#39;, data):
            for match in pattern.finditer(zm[::2]):
                yield match</code></pre>
</details>
</dd>
<dt id="refinery.units.pattern.PatternExtractorBase.matchfilter"><code class="name flex">
<span>def <span class="ident">matchfilter</span></span>(<span>self, matches)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L208-L209" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matchfilter(self, matches: Iterable[re.Match]) -&gt; Iterable[re.Match]:
    yield from self._postfilter(self._prefilter(matches))</code></pre>
</details>
</dd>
<dt id="refinery.units.pattern.PatternExtractorBase.matches_filtered"><code class="name flex">
<span>def <span class="ident">matches_filtered</span></span>(<span>self, data, pattern, *transforms)</span>
</code></dt>
<dd>
<section class="desc"><p>This is a wrapper for <code>AbstractRegexUint.matches</code> which filters the
results according to the given commandline arguments. Returns a
dictionary mapping its position (start, end) in the input data to the
filtered and transformed match that was found at this position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L211-L234" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matches_filtered(
    self,
    data: ByteString,
    pattern: Union[ByteString, re.Pattern],
    *transforms: Optional[Iterable[Callable[[re.Match], Optional[Union[Dict, ByteString]]]]]
) -&gt; Iterable[Union[Dict, ByteString]]:
    &#34;&#34;&#34;
    This is a wrapper for `AbstractRegexUint.matches` which filters the
    results according to the given commandline arguments. Returns a
    dictionary mapping its position (start, end) in the input data to the
    filtered and transformed match that was found at this position.
    &#34;&#34;&#34;
    def funcify(t):
        def const(m): return t
        return t if callable(t) else const

    transforms = [funcify(f) for f in transforms] or [lambda m: m[0]]

    if self.args.stripspace:
        data = re.sub(BR&#39;\s+&#39;, B&#39;&#39;, data)
    for match in self.matchfilter(self.matches(memoryview(data), pattern)):
        for transform in transforms:
            t = transform(match)
            if t is not None: yield t</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.detach" href="../index.html#refinery.units.Unit.detach">detach</a></code></li>
<li><code><a title="refinery.units.Unit.filter" href="../index.html#refinery.units.Unit.filter">filter</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.output" href="../index.html#refinery.units.Unit.output">output</a></code></li>
<li><code><a title="refinery.units.Unit.process" href="../index.html#refinery.units.Unit.process">process</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.pattern.PatternExtractor"><code class="flex name class">
<span>class <span class="ident">PatternExtractor</span></span>
<span>(</span><span>min=1, max=None, len=None, stripspace=False, unique=False, longest=False, take=None, ascii=True, utf16=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L237-L253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PatternExtractor(PatternExtractorBase, abstract=True):
    def __init__(
        self, min=1, max=None, len=None, stripspace=False, unique=False, longest=False, take=None,
        ascii: arg.switch(&#39;-u&#39;, &#39;--no-ascii&#39;, group=&#39;AvsU&#39;, help=&#39;Search for UTF16 encoded patterns only.&#39;) = True,
        utf16: arg.switch(&#39;-a&#39;, &#39;--no-utf16&#39;, group=&#39;AvsU&#39;, help=&#39;Search for ASCII encoded patterns only.&#39;) = True,
    ):
        super().__init__(
            min=min,
            max=max,
            len=len,
            stripspace=stripspace,
            unique=unique,
            longest=longest,
            take=take
        )
        self.args.ascii = ascii
        self.args.utf16 = utf16</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.PatternExtractorBase" href="#refinery.units.pattern.PatternExtractorBase">PatternExtractorBase</a></li>
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.carve.carve" href="carve.html#refinery.units.pattern.carve.carve">carve</a></li>
<li><a title="refinery.units.pattern.xtp.xtp" href="xtp.html#refinery.units.pattern.xtp.xtp">xtp</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.pattern.PatternExtractor.argspec"><code class="name">var <span class="ident">argspec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.pattern.PatternExtractorBase" href="#refinery.units.pattern.PatternExtractorBase">PatternExtractorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.pattern.PatternExtractorBase.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.detach" href="../index.html#refinery.units.Unit.detach">detach</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.filter" href="../index.html#refinery.units.Unit.filter">filter</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.matches" href="#refinery.units.pattern.PatternExtractorBase.matches">matches</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.matches_filtered" href="#refinery.units.pattern.PatternExtractorBase.matches_filtered">matches_filtered</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.output" href="../index.html#refinery.units.Unit.output">output</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.process" href="../index.html#refinery.units.Unit.process">process</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.pattern.RegexUnit"><code class="flex name class">
<span>class <span class="ident">RegexUnit</span></span>
<span>(</span><span>regex, multiline=False, ignorecase=False, utf16=False, min=1, max=None, len=None, stripspace=False, unique=False, longest=False, take=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/units/pattern/__init__.py#L256-L287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RegexUnit(PatternExtractorBase, abstract=True):

    def __init__(
        self, regex : arg(type=regexp, help=&#39;Regular expression to match.&#39;),
        # TODO: Use positional only in Python 3.8
        # /,
        multiline   : arg.switch(&#39;-M&#39;, help=&#39;Caret and dollar match the beginning and end of &#39;
                                            &#39;a line, a dot does not match line breaks.&#39;) = False,
        ignorecase  : arg.switch(&#39;-I&#39;, help=&#39;Ignore capitalization for alphabetic characters.&#39;) = False,
        utf16       : arg.switch(&#39;-u&#39;, help=&#39;Search for unicode patterns instead of ascii.&#39;) = False,
        min=1, max=None, len=None, stripspace=False, unique=False, longest=False, take=None
    ):
        super().__init__(
            min=min,
            max=max,
            len=len,
            stripspace=stripspace,
            unique=unique,
            longest=longest,
            take=take
        )

        self.args.utf16 = utf16
        self.args.ascii = not utf16

        regex_flags = B&#39;m&#39; if multiline else B&#39;s&#39;
        if ignorecase: regex_flags += B&#39;i&#39;

        if isinstance(regex, str):
            regex = regex.encode(self.codec)

        self.args.regex = B&#39;(?%s)%s&#39; % (regex_flags, regex)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.PatternExtractorBase" href="#refinery.units.pattern.PatternExtractorBase">PatternExtractorBase</a></li>
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.resplit.resplit" href="resplit.html#refinery.units.pattern.resplit.resplit">resplit</a></li>
<li><a title="refinery.units.pattern.resub.resub" href="resub.html#refinery.units.pattern.resub.resub">resub</a></li>
<li><a title="refinery.units.pattern.rex.rex" href="rex.html#refinery.units.pattern.rex.rex">rex</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.pattern.RegexUnit.argspec"><code class="name">var <span class="ident">argspec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.pattern.PatternExtractorBase" href="#refinery.units.pattern.PatternExtractorBase">PatternExtractorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.pattern.PatternExtractorBase.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.detach" href="../index.html#refinery.units.Unit.detach">detach</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.filter" href="../index.html#refinery.units.Unit.filter">filter</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.matches" href="#refinery.units.pattern.PatternExtractorBase.matches">matches</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.matches_filtered" href="#refinery.units.pattern.PatternExtractorBase.matches_filtered">matches_filtered</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.output" href="../index.html#refinery.units.Unit.output">output</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.process" href="../index.html#refinery.units.Unit.process">process</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units" href="../index.html">refinery.units</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="refinery.units.pattern.carve" href="carve.html">refinery.units.pattern.carve</a></code></li>
<li><code><a title="refinery.units.pattern.carve_json" href="carve_json.html">refinery.units.pattern.carve_json</a></code></li>
<li><code><a title="refinery.units.pattern.carve_pe" href="carve_pe.html">refinery.units.pattern.carve_pe</a></code></li>
<li><code><a title="refinery.units.pattern.carve_xml" href="carve_xml.html">refinery.units.pattern.carve_xml</a></code></li>
<li><code><a title="refinery.units.pattern.carve_zip" href="carve_zip.html">refinery.units.pattern.carve_zip</a></code></li>
<li><code><a title="refinery.units.pattern.defang" href="defang.html">refinery.units.pattern.defang</a></code></li>
<li><code><a title="refinery.units.pattern.dnsdomain" href="dnsdomain.html">refinery.units.pattern.dnsdomain</a></code></li>
<li><code><a title="refinery.units.pattern.mimewords" href="mimewords.html">refinery.units.pattern.mimewords</a></code></li>
<li><code><a title="refinery.units.pattern.resplit" href="resplit.html">refinery.units.pattern.resplit</a></code></li>
<li><code><a title="refinery.units.pattern.resub" href="resub.html">refinery.units.pattern.resub</a></code></li>
<li><code><a title="refinery.units.pattern.rex" href="rex.html">refinery.units.pattern.rex</a></code></li>
<li><code><a title="refinery.units.pattern.urlguards" href="urlguards.html">refinery.units.pattern.urlguards</a></code></li>
<li><code><a title="refinery.units.pattern.xtp" href="xtp.html">refinery.units.pattern.xtp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.pattern.TransformSubstitutionFactory" href="#refinery.units.pattern.TransformSubstitutionFactory">TransformSubstitutionFactory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.pattern.PatternExtractorBase" href="#refinery.units.pattern.PatternExtractorBase">PatternExtractorBase</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.pattern.PatternExtractorBase.matches" href="#refinery.units.pattern.PatternExtractorBase.matches">matches</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.matchfilter" href="#refinery.units.pattern.PatternExtractorBase.matchfilter">matchfilter</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractorBase.matches_filtered" href="#refinery.units.pattern.PatternExtractorBase.matches_filtered">matches_filtered</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.pattern.PatternExtractor" href="#refinery.units.pattern.PatternExtractor">PatternExtractor</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.pattern.RegexUnit" href="#refinery.units.pattern.RegexUnit">RegexUnit</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>