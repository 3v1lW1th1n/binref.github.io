<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>the refinery.lib.frame documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:12pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #EEEEEE}#index ul{padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #EEEEEE}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.frame</code></h1>
</header>
<section id="section-intro">
<p>Some refinery units produce more than one output when applied to an input. For example,
<code><a title="refinery.chop" href="../index.html#refinery.chop">chop</a></code> will chop the input data into evenly sized blocks and emit each of them
as a single output. By default, if no framing syntax is used, multiple outputs are
separated by line breaks, which is often desirable when text data is extracted. However,
for processing binary data, this is equally often more than useless. To process the list
of results generated by any refinery unit, end the command for this unit with the
special argument <code>[</code>. This argument has to be the last argument to be recognized as a
framing initialization. If this syntax is used, the list of results is emitted in an
internal format which allows arbitrarily nested lists of binary chunks to be processed.</p>
<h3 id="simple-frame-example">Simple Frame Example</h3>
<pre><code>$ emit OOOOOOOO | chop 2 [| ccp F | cca . ]
FOO.FOO.FOO.FOO.
</code></pre>
<p>Here, the string <code>OOOOOOOO</code> is first chopped into blocks of 2, yielding the <strong>frame</strong>
<code>[OO, OO, OO, OO]</code> which is then forwarded to the next command. If a <code><a title="refinery.units.Unit" href="../units/index.html#refinery.units.Unit">Unit</a></code>
receives input in framed format, each chunk of the frame is processed individually and
emitted as one output chunk. In this case, <code><a title="refinery.ccp" href="../index.html#refinery.ccp">ccp</a></code> simply prepends <code>F</code> to every
input, producing the frame <code>[FOO, FOO, FOO, FOO]</code>. Finally, <code><a title="refinery.cca" href="../index.html#refinery.cca">cca</a></code> appends a period
to each chunk. When a unit is given the closing bracket as the last argument, this
concludes processing of one frame which results in concatenation of all binary chunks in
the frame.</p>
<h3 id="frame-layers">Frame Layers</h3>
<p>Frames can be nested arbitrarily, and <code><a title="refinery.sep" href="../index.html#refinery.sep">sep</a></code> can be used to insert a separator
(the default is line break) between all chunks in the frame:</p>
<pre><code>$ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]| sep ]
FOO.FOO.
FOO.FOO.
</code></pre>
<p>Here, we first produce the two-layered <strong>frame tree</strong> <code>[[OO,OO], [OO,OO]]</code> by using two
<code><a title="refinery.chop" href="../index.html#refinery.chop">chop</a></code> invocations. We refer to this data as a tree because, well, it is one:</p>
<pre><code>LAYER 1:      [[..],[..]]
                /     \
LAYER 2:    [OO,OO] [OO,OO]
</code></pre>
<p>The bottom layer is processed as before, yielding <code>[FOO.FOO., FOO.FOO.]</code>. Next, the unit
<code><a title="refinery.sep" href="../index.html#refinery.sep">sep</a></code> inserts a line break character between the two chunks in this frame.</p>
<h3 id="adding-line-breaks-easily">Adding Line Breaks Easily</h3>
<p>Since separating data with line breaks is a common requirement, it is also possible to use
one more closing bracket than necessary at the end of a frame to separate all chunks by line
breaks:</p>
<pre><code>$ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]]]
FOO.FOO.
FOO.FOO.
</code></pre>
<h3 id="scoping">Scoping</h3>
<p>It is possible to alter the <strong>visibility</strong> of <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code>, primarily by
using <code><a title="refinery.scope" href="../index.html#refinery.scope">scope</a></code>. The unit accepts a slice argument which defines the indices of
the current frame that remain visible. All subsequent units will only process visible
chunks and simply forward the ones that are not visible. <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code>s
remain invisible when a new frame layer opens:</p>
<pre><code>$ emit BINARY REFINERY [| scope 0 | clower | sep - ]
binary-REFINERY
</code></pre>
<p>Here, the scope was limited to the first chunk <code>BINARY</code> which was transformed to lower
case, but the second chunk <code>REFINERY</code> was left untouched. A somewhat more complex example:</p>
<pre><code>$ emit aaaaaaaa namtaB [| scope 0 | rex . [| ccp N ]| scope 1 | rev | sep - ]
NaNaNaNaNaNaNaNa-Batman
</code></pre>
<p>Note that <code><a title="refinery.sep" href="../index.html#refinery.sep">sep</a></code> makes all chunks in the frame visible by default, because it is
intended to sit at the end of a frame. Otherwise, <code>NaNaNaNaNaNaNaNa</code> and <code>Batman</code> in the
above example would not be separated by a dash.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L0-L479" class="git-link">Browse git</a>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
R&#34;&#34;&#34;
Some refinery units produce more than one output when applied to an input. For example,
`refinery.chop` will chop the input data into evenly sized blocks and emit each of them
as a single output. By default, if no framing syntax is used, multiple outputs are
separated by line breaks, which is often desirable when text data is extracted. However,
for processing binary data, this is equally often more than useless. To process the list
of results generated by any refinery unit, end the command for this unit with the
special argument `[`. This argument has to be the last argument to be recognized as a
framing initialization. If this syntax is used, the list of results is emitted in an
internal format which allows arbitrarily nested lists of binary chunks to be processed.

### Simple Frame Example

    $ emit OOOOOOOO | chop 2 [| ccp F | cca . ]
    FOO.FOO.FOO.FOO.

Here, the string `OOOOOOOO` is first chopped into blocks of 2, yielding the **frame**
`[OO, OO, OO, OO]` which is then forwarded to the next command. If a `refinery.units.Unit`
receives input in framed format, each chunk of the frame is processed individually and
emitted as one output chunk. In this case, `refinery.ccp` simply prepends `F` to every
input, producing the frame `[FOO, FOO, FOO, FOO]`. Finally, `refinery.cca` appends a period
to each chunk. When a unit is given the closing bracket as the last argument, this
concludes processing of one frame which results in concatenation of all binary chunks in
the frame.

### Frame Layers

Frames can be nested arbitrarily, and `refinery.sep` can be used to insert a separator
(the default is line break) between all chunks in the frame:

    $ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]| sep ]
    FOO.FOO.
    FOO.FOO.

Here, we first produce the two-layered **frame tree** `[[OO,OO], [OO,OO]]` by using two
`refinery.chop` invocations. We refer to this data as a tree because, well, it is one:

    LAYER 1:      [[..],[..]]
                    /     \
    LAYER 2:    [OO,OO] [OO,OO]

The bottom layer is processed as before, yielding `[FOO.FOO., FOO.FOO.]`. Next, the unit
`refinery.sep` inserts a line break character between the two chunks in this frame.

### Adding Line Breaks Easily

Since separating data with line breaks is a common requirement, it is also possible to use
one more closing bracket than necessary at the end of a frame to separate all chunks by line
breaks:

    $ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]]]
    FOO.FOO.
    FOO.FOO.

### Scoping

It is possible to alter the **visibility** of `refinery.lib.frame.Chunk`, primarily by
using `refinery.scope`. The unit accepts a slice argument which defines the indices of
the current frame that remain visible. All subsequent units will only process visible
chunks and simply forward the ones that are not visible. `refinery.lib.frame.Chunk`s
remain invisible when a new frame layer opens:

    $ emit BINARY REFINERY [| scope 0 | clower | sep - ]
    binary-REFINERY

Here, the scope was limited to the first chunk `BINARY` which was transformed to lower
case, but the second chunk `REFINERY` was left untouched. A somewhat more complex example:

    $ emit aaaaaaaa namtaB [| scope 0 | rex . [| ccp N ]| scope 1 | rev | sep - ]
    NaNaNaNaNaNaNaNa-Batman

Note that `refinery.sep` makes all chunks in the frame visible by default, because it is
intended to sit at the end of a frame. Otherwise, `NaNaNaNaNaNaNaNa` and `Batman` in the
above example would not be separated by a dash.
&#34;&#34;&#34;
import io
import os

from typing import Iterable, BinaryIO, Callable, Optional, Tuple, Dict, ByteString, Any

try:
    import msgpack
except ModuleNotFoundError:
    msgpack = None

__all__ = [
    &#39;Chunk&#39;,
    &#39;Framed&#39;,
    &#39;FrameUnpacker&#39;
]

MAGIC = bytes.fromhex(
    os.environ.get(&#39;REFINERY_FRAME_MAGIC&#39;, &#39;C0CAC01AC0DE&#39;))


class Chunk(bytearray):
    &#34;&#34;&#34;
    Represents the individual chunks in a frame. The `refinery.units.Unit.filter` method
    receives an iterable of `refinery.lib.frame.Chunk`s.
    &#34;&#34;&#34;
    def __init__(
        self,
        data: ByteString,
        path: Tuple[int] = (),
        view: Optional[Tuple[bool]] = None,
        meta: Optional[Dict[str, Any]] = None,
        fill: Optional[bool] = None
    ):
        view = view or (False,) * len(path)
        if len(view) != len(path):
            raise ValueError(&#39;skipping must have the same length as path&#39;)

        if isinstance(data, Chunk):
            path = path or data.path
            view = view or data.view
            meta = meta or data.meta
            fill = fill or data.fill

        self._view: Tuple[bool] = view
        self._path: Tuple[int] = path
        self._meta: Dict[str, Any] = meta or dict()
        self._fill: bool = fill

        bytearray.__init__(self, data)

    @property
    def fill(self) -&gt; bool:
        return self._fill

    def set_next_scope(self, visible: bool) -&gt; None:
        self._fill = visible

    def truncate(self, gauge):
        self._path = self._path[:gauge]
        self._view = self._view[:gauge]

    def nest(self, *ids):
        &#34;&#34;&#34;
        Nest this chunk deeper by providing a sequence of indices inside each new layer of the
        frame. The `refinery.lib.frame.Chunk.path` tuple is extended by these values. The
        visibility of the `refinery.lib.frame.Chunk` at each new layer is inherited from its
        current visibility.
        &#34;&#34;&#34;
        if self._fill is not None:
            self._view += (self.visible,) * (len(ids) - 1) + (self._fill,)
            self._fill = None
        else:
            self._view += (self.visible,) * len(ids)
        self._path += ids
        return self

    @property
    def view(self) -&gt; Tuple[bool]:
        &#34;&#34;&#34;
        This tuple of boolean values indicates the visibility of this chunk at each layer of
        the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
        within a frame.
        &#34;&#34;&#34;
        return self._view

    @property
    def path(self) -&gt; Tuple[int]:
        &#34;&#34;&#34;
        The vertices in each frame tree layer are sequentially numbered by their order of
        appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
        the vertices (in each layer) which define the path from the root of the frame tree
        to the leaf vertex representing this `refinery.lib.frame.Chunk`
        &#34;&#34;&#34;
        return self._path

    @property
    def meta(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Every chunk can contain a dictionary of arbitrary metadata.
        &#34;&#34;&#34;
        return self._meta

    @property
    def visible(self):
        &#34;&#34;&#34;
        This property defines whether the chunk is currently visible. It defaults to true if the
        chunk is not part of a frame and is otherwise the same as the last element of the tuple
        `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
        entry of `refinery.lib.frame.Chunk.view`.
        Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
        &#34;&#34;&#34;
        return not self._view or self._view[~0]

    @property
    def scopable(self):
        &#34;&#34;&#34;
        This property defines whether the chunk can be made visible in the current frame.
        &#34;&#34;&#34;
        return len(self._view) &lt;= 1 or self._view[~1]

    @visible.setter
    def visible(self, value: bool):
        if not self._view:
            raise AttributeError(&#39;cannot set visibility of chunk outside frame&#39;)
        if value != self.visible:
            self._view = self._view[:~0] + (value,)

    def inherit(self, parent):
        &#34;&#34;&#34;
        This method can be used to take over properties of a parent `refinery.lib.frame.Chunk`.
        &#34;&#34;&#34;
        self._path = parent._path
        self._view = parent._view
        for key, value in parent._meta.items():
            if key not in self._meta:
                self._meta[key] = value

    @classmethod
    def unpack(cls, stream):
        &#34;&#34;&#34;
        Classmethod to read a serialized chunk from an unpacker stream.
        &#34;&#34;&#34;
        path, view, meta, fill, data = next(stream)
        return cls(data, path, view=view, meta=meta, fill=fill)

    def pack(self):
        &#34;&#34;&#34;
        Return the serialized representation of this chunk.
        &#34;&#34;&#34;
        return msgpack.packb((self._path, self._view, self._meta, self._fill, self))

    def __repr__(self) -&gt; str:
        layer = &#39;/&#39;.join(&#39;#&#39; if not s else str(p) for p, s in zip(self._path, self._view))
        layer = layer and &#39;/&#39; + layer
        metas = &#39;,&#39;.join(self._meta)
        metas = metas and F&#39; meta=({metas})&#39;
        return F&#39;&lt;chunk{layer}{metas} size={len(self)} data={repr(bytes(self))}&gt;&#39;

    def __hash__(self):
        return hash((
            len(self),
            bytes(self[:+64]),
            bytes(self[-64:])
        ))

    def __getitem__(self, bounds):
        if isinstance(bounds, str):
            return self._meta.get(bounds, None)
        return bytearray.__getitem__(self, bounds)

    def __setitem__(self, bounds, value):
        if isinstance(bounds, str):
            self._meta[bounds] = value
        else:
            bytearray.__setitem__(self, bounds, value)

    def __copy__(self):
        return Chunk(self, self._path, self._view, self._meta, self._fill)

    def __deepcopy__(self, memo):
        from copy import deepcopy
        copy = Chunk(self, self._path, self._view, self._fill)
        memo[id(self)] = copy
        copy._meta = deepcopy(self._meta, memo)
        return copy


class FrameUnpacker:
    &#34;&#34;&#34;
    Provides a unified interface to read both framed and raw input data from a stream. After
    loading a framed input stream, the object provides an iterator over the first **frame** in
    the bottom **layer** of the frame tree. Consider this doubly layered frame tree:

        [[FOO, BAR], [BOO, BAZ]]

    The `refinery.lib.frame.FrameUnpacker` object will first be an iterator over the first frame
    `[FOO, BAR]`. After consuming this iterator, the `refinery.lib.frame.FrameUnpacker.nextframe`
    method can be called to load the next frame, at which point the object will become an
    iterator over `[BOO, BAZ]`.
    &#34;&#34;&#34;
    def __init__(self, stream: Optional[BinaryIO]):
        import msgpack
        self.finished = False
        self.trunk = ()
        self._next = Chunk(bytearray(), ())
        buffer = stream and stream.read(len(MAGIC)) or B&#39;&#39;
        if buffer == MAGIC:
            self.framed = True
            self.stream = stream
            self.unpacker = msgpack.Unpacker(
                max_buffer_size=0xFFFFFFFF,
                use_list=False
            )
            self._advance()
            self.gauge = len(self._next.path)
        else:
            self.framed = False
            self.gauge = 0
            while buffer:
                self._next.extend(buffer)
                buffer = stream.read()

    def _advance(self) -&gt; None:
        while not self.finished:
            try:
                self._next = Chunk.unpack(self.unpacker)
                break
            except StopIteration:
                pass
            try:
                recv = self.stream.read1() or self.stream.read()
            except TypeError:
                recv = self.stream.read()
            if recv:
                self.unpacker.feed(recv)
                continue
            self.finished = True

    def nextframe(self) -&gt; bool:
        &#34;&#34;&#34;
        Once the iterator is consumed, calling this function will return `True` if
        and only if another frame with input data has been loaded, in which case
        the object will provide an iterator over the freshly loaded frame. If this
        function returns `False`, all input data has been consumed.
        &#34;&#34;&#34;
        if self.finished:
            return False
        self.trunk = self._next.path
        return True

    @property
    def eol(self) -&gt; bool:
        return self.trunk != self.peek

    @property
    def peek(self) -&gt; Tuple[int]:
        &#34;&#34;&#34;
        Contains the identifier of the next frame.
        &#34;&#34;&#34;
        return self._next.path

    def __iter__(self) -&gt; Iterable[Chunk]:
        if self.finished:
            return
        if not self.framed:
            yield self._next
            self.finished = True
            return
        while not self.finished and self.trunk == self._next.path:
            yield self._next
            self._advance()


class Framed:
    &#34;&#34;&#34;
    A proxy interface to ingest and output framed data. It is given an `action` to be
    performed for each elementary chunk of data, a `stream` of input data, and an integer
    argument `nested` which specifies the relative amount of nesting to be performed
    by the interface. This parameter should either be `1` if the interface should output
    the results at an additional layer, `0` if the nesting depth of the data should
    remain unchanged, and a negative amount if frame layers are to be collapsed. After
    initialization, the `refinery.lib.frame.Framed` object is an iterator that yields
    bytestrings which can be forwarded as the output of the operation with all framing
    already taken care of.
    &#34;&#34;&#34;
    def __init__(
        self,
        action: Callable[[bytearray], Iterable[Chunk]],
        stream: BinaryIO,
        nested: int = 0,
        filter: Optional[Callable[[Iterable[Chunk]], Iterable[Chunk]]] = None,
    ):
        self.unpack = FrameUnpacker(stream)
        self.action = action
        self.nested = nested
        self.filter = filter

    def _apply_filter(self) -&gt; Iterable[Chunk]:

        it = iter(self.unpack)

        def rewind():
            yield top
            yield from it

        try:
            top = next(it)
        except StopIteration:
            pass
        else:
            rw = rewind()
            yield from self.filter(rw) if top.scopable else rw

        if not self.unpack.eol:  # filter did not consume the iterable
            for _ in self.unpack:
                pass

    @property
    def unframed(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is true if the output data is not framed.
        &#34;&#34;&#34;
        return self.nested &lt; 1 and not self.unpack.framed

    @property
    def framebreak(self) -&gt; bool:
        &#34;&#34;&#34;
        This property will be true if the data generated by this framing interface
        is unframed, and the requested nesting was smaller than required to achieve
        this. In practice, it means that the user has provided more closing brakcets
        than were required to close all open frames.
        &#34;&#34;&#34;
        return self.nested + self.unpack.gauge &lt; 0

    def _generate_chunks(self, parent: Chunk):
        for item in self.action(parent):
            item = item.__copy__()
            item.inherit(parent)
            yield item

    def _generate_bytes(self, data: ByteString):
        yield from self.action(data)

    def __iter__(self):
        if self.unpack.finished:
            return

        if self.nested &gt; 0:
            yield MAGIC
            rest = (0,) * (self.nested - 1)
            while self.unpack.nextframe():
                for k, chunk in enumerate(self._apply_filter()):
                    if not chunk.visible:
                        yield chunk.nest(k, *rest).pack()
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.nest(k, *rest).pack()
            return

        elif not self.unpack.framed:
            for chunk in self._apply_filter():
                yield from self._generate_bytes(chunk)
            return

        if self.nested == 0:
            yield MAGIC
            while self.unpack.nextframe():
                for chunk in self._apply_filter():
                    if not chunk.visible:
                        yield chunk.pack()
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.pack()
            return

        gauge = max(self.unpack.gauge + self.nested, 0)

        if gauge:
            buffer = io.BytesIO()
            yield MAGIC
        while self.unpack.nextframe():
            while True:
                for chunk in self._apply_filter():
                    results = self._generate_bytes(chunk) if chunk.visible else (chunk,)
                    for result in results:
                        if not gauge:
                            yield result
                            continue
                        buffer.write(result)
                if self.unpack.peek[:gauge + 1] != self.unpack.trunk[:gauge + 1]:
                    break
                if not self.unpack.nextframe():
                    break
            if gauge:
                buffer.truncate(buffer.tell())
                collapsed = buffer.getvalue()
                try:
                    chunk[:] = collapsed
                    chunk.truncate(gauge)
                except NameError:
                    chunk = Chunk(collapsed, self.unpack.trunk[:gauge])
                yield chunk.pack()
                buffer.seek(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.frame.Chunk"><code class="flex name class">
<span>class <span class="ident">Chunk</span></span>
<span>(</span><span>data, path=(), view=None, meta=None, fill=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Represents the individual chunks in a frame. The <code><a title="refinery.units.Unit.filter" href="../units/index.html#refinery.units.Unit.filter">Unit.filter()</a></code> method
receives an iterable of <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code>s.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L98-L262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Chunk(bytearray):
    &#34;&#34;&#34;
    Represents the individual chunks in a frame. The `refinery.units.Unit.filter` method
    receives an iterable of `refinery.lib.frame.Chunk`s.
    &#34;&#34;&#34;
    def __init__(
        self,
        data: ByteString,
        path: Tuple[int] = (),
        view: Optional[Tuple[bool]] = None,
        meta: Optional[Dict[str, Any]] = None,
        fill: Optional[bool] = None
    ):
        view = view or (False,) * len(path)
        if len(view) != len(path):
            raise ValueError(&#39;skipping must have the same length as path&#39;)

        if isinstance(data, Chunk):
            path = path or data.path
            view = view or data.view
            meta = meta or data.meta
            fill = fill or data.fill

        self._view: Tuple[bool] = view
        self._path: Tuple[int] = path
        self._meta: Dict[str, Any] = meta or dict()
        self._fill: bool = fill

        bytearray.__init__(self, data)

    @property
    def fill(self) -&gt; bool:
        return self._fill

    def set_next_scope(self, visible: bool) -&gt; None:
        self._fill = visible

    def truncate(self, gauge):
        self._path = self._path[:gauge]
        self._view = self._view[:gauge]

    def nest(self, *ids):
        &#34;&#34;&#34;
        Nest this chunk deeper by providing a sequence of indices inside each new layer of the
        frame. The `refinery.lib.frame.Chunk.path` tuple is extended by these values. The
        visibility of the `refinery.lib.frame.Chunk` at each new layer is inherited from its
        current visibility.
        &#34;&#34;&#34;
        if self._fill is not None:
            self._view += (self.visible,) * (len(ids) - 1) + (self._fill,)
            self._fill = None
        else:
            self._view += (self.visible,) * len(ids)
        self._path += ids
        return self

    @property
    def view(self) -&gt; Tuple[bool]:
        &#34;&#34;&#34;
        This tuple of boolean values indicates the visibility of this chunk at each layer of
        the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
        within a frame.
        &#34;&#34;&#34;
        return self._view

    @property
    def path(self) -&gt; Tuple[int]:
        &#34;&#34;&#34;
        The vertices in each frame tree layer are sequentially numbered by their order of
        appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
        the vertices (in each layer) which define the path from the root of the frame tree
        to the leaf vertex representing this `refinery.lib.frame.Chunk`
        &#34;&#34;&#34;
        return self._path

    @property
    def meta(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Every chunk can contain a dictionary of arbitrary metadata.
        &#34;&#34;&#34;
        return self._meta

    @property
    def visible(self):
        &#34;&#34;&#34;
        This property defines whether the chunk is currently visible. It defaults to true if the
        chunk is not part of a frame and is otherwise the same as the last element of the tuple
        `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
        entry of `refinery.lib.frame.Chunk.view`.
        Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
        &#34;&#34;&#34;
        return not self._view or self._view[~0]

    @property
    def scopable(self):
        &#34;&#34;&#34;
        This property defines whether the chunk can be made visible in the current frame.
        &#34;&#34;&#34;
        return len(self._view) &lt;= 1 or self._view[~1]

    @visible.setter
    def visible(self, value: bool):
        if not self._view:
            raise AttributeError(&#39;cannot set visibility of chunk outside frame&#39;)
        if value != self.visible:
            self._view = self._view[:~0] + (value,)

    def inherit(self, parent):
        &#34;&#34;&#34;
        This method can be used to take over properties of a parent `refinery.lib.frame.Chunk`.
        &#34;&#34;&#34;
        self._path = parent._path
        self._view = parent._view
        for key, value in parent._meta.items():
            if key not in self._meta:
                self._meta[key] = value

    @classmethod
    def unpack(cls, stream):
        &#34;&#34;&#34;
        Classmethod to read a serialized chunk from an unpacker stream.
        &#34;&#34;&#34;
        path, view, meta, fill, data = next(stream)
        return cls(data, path, view=view, meta=meta, fill=fill)

    def pack(self):
        &#34;&#34;&#34;
        Return the serialized representation of this chunk.
        &#34;&#34;&#34;
        return msgpack.packb((self._path, self._view, self._meta, self._fill, self))

    def __repr__(self) -&gt; str:
        layer = &#39;/&#39;.join(&#39;#&#39; if not s else str(p) for p, s in zip(self._path, self._view))
        layer = layer and &#39;/&#39; + layer
        metas = &#39;,&#39;.join(self._meta)
        metas = metas and F&#39; meta=({metas})&#39;
        return F&#39;&lt;chunk{layer}{metas} size={len(self)} data={repr(bytes(self))}&gt;&#39;

    def __hash__(self):
        return hash((
            len(self),
            bytes(self[:+64]),
            bytes(self[-64:])
        ))

    def __getitem__(self, bounds):
        if isinstance(bounds, str):
            return self._meta.get(bounds, None)
        return bytearray.__getitem__(self, bounds)

    def __setitem__(self, bounds, value):
        if isinstance(bounds, str):
            self._meta[bounds] = value
        else:
            bytearray.__setitem__(self, bounds, value)

    def __copy__(self):
        return Chunk(self, self._path, self._view, self._meta, self._fill)

    def __deepcopy__(self, memo):
        from copy import deepcopy
        copy = Chunk(self, self._path, self._view, self._fill)
        memo[id(self)] = copy
        copy._meta = deepcopy(self._meta, memo)
        return copy</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytearray</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.frame.Chunk.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>stream)</span>
</code></dt>
<dd>
<section class="desc"><p>Classmethod to read a serialized chunk from an unpacker stream.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L215-L221" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def unpack(cls, stream):
    &#34;&#34;&#34;
    Classmethod to read a serialized chunk from an unpacker stream.
    &#34;&#34;&#34;
    path, view, meta, fill, data = next(stream)
    return cls(data, path, view=view, meta=meta, fill=fill)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.frame.Chunk.fill"><code class="name">var <span class="ident">fill</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L128-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def fill(self) -&gt; bool:
    return self._fill</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.view"><code class="name">var <span class="ident">view</span></code></dt>
<dd>
<section class="desc"><p>This tuple of boolean values indicates the visibility of this chunk at each layer of
the frame tree. The <code><a title="refinery.scope" href="../index.html#refinery.scope">scope</a></code> unit can be used to change visibility of chunks
within a frame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L154-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def view(self) -&gt; Tuple[bool]:
    &#34;&#34;&#34;
    This tuple of boolean values indicates the visibility of this chunk at each layer of
    the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
    within a frame.
    &#34;&#34;&#34;
    return self._view</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<section class="desc"><p>The vertices in each frame tree layer are sequentially numbered by their order of
appearance in the stream. The <code><a title="refinery.lib.frame.Chunk.path" href="#refinery.lib.frame.Chunk.path">Chunk.path</a></code> contains the numbers of
the vertices (in each layer) which define the path from the root of the frame tree
to the leaf vertex representing this <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L163-L171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def path(self) -&gt; Tuple[int]:
    &#34;&#34;&#34;
    The vertices in each frame tree layer are sequentially numbered by their order of
    appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
    the vertices (in each layer) which define the path from the root of the frame tree
    to the leaf vertex representing this `refinery.lib.frame.Chunk`
    &#34;&#34;&#34;
    return self._path</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.meta"><code class="name">var <span class="ident">meta</span></code></dt>
<dd>
<section class="desc"><p>Every chunk can contain a dictionary of arbitrary metadata.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L173-L178" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def meta(self) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Every chunk can contain a dictionary of arbitrary metadata.
    &#34;&#34;&#34;
    return self._meta</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<section class="desc"><p>This property defines whether the chunk is currently visible. It defaults to true if the
chunk is not part of a frame and is otherwise the same as the last element of the tuple
<code><a title="refinery.lib.frame.Chunk.view" href="#refinery.lib.frame.Chunk.view">Chunk.view</a></code>. Setting this property will correspondingly alter the last
entry of <code><a title="refinery.lib.frame.Chunk.view" href="#refinery.lib.frame.Chunk.view">Chunk.view</a></code>.
Setting this property on an unframed <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code> raises an <code>AttributeError</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L180-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def visible(self):
    &#34;&#34;&#34;
    This property defines whether the chunk is currently visible. It defaults to true if the
    chunk is not part of a frame and is otherwise the same as the last element of the tuple
    `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
    entry of `refinery.lib.frame.Chunk.view`.
    Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
    &#34;&#34;&#34;
    return not self._view or self._view[~0]</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.scopable"><code class="name">var <span class="ident">scopable</span></code></dt>
<dd>
<section class="desc"><p>This property defines whether the chunk can be made visible in the current frame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L191-L196" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def scopable(self):
    &#34;&#34;&#34;
    This property defines whether the chunk can be made visible in the current frame.
    &#34;&#34;&#34;
    return len(self._view) &lt;= 1 or self._view[~1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.frame.Chunk.set_next_scope"><code class="name flex">
<span>def <span class="ident">set_next_scope</span></span>(<span>self, visible)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L132-L133" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_next_scope(self, visible: bool) -&gt; None:
    self._fill = visible</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, gauge)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L135-L137" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate(self, gauge):
    self._path = self._path[:gauge]
    self._view = self._view[:gauge]</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.nest"><code class="name flex">
<span>def <span class="ident">nest</span></span>(<span>self, *ids)</span>
</code></dt>
<dd>
<section class="desc"><p>Nest this chunk deeper by providing a sequence of indices inside each new layer of the
frame. The <code><a title="refinery.lib.frame.Chunk.path" href="#refinery.lib.frame.Chunk.path">Chunk.path</a></code> tuple is extended by these values. The
visibility of the <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code> at each new layer is inherited from its
current visibility.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L139-L152" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nest(self, *ids):
    &#34;&#34;&#34;
    Nest this chunk deeper by providing a sequence of indices inside each new layer of the
    frame. The `refinery.lib.frame.Chunk.path` tuple is extended by these values. The
    visibility of the `refinery.lib.frame.Chunk` at each new layer is inherited from its
    current visibility.
    &#34;&#34;&#34;
    if self._fill is not None:
        self._view += (self.visible,) * (len(ids) - 1) + (self._fill,)
        self._fill = None
    else:
        self._view += (self.visible,) * len(ids)
    self._path += ids
    return self</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.inherit"><code class="name flex">
<span>def <span class="ident">inherit</span></span>(<span>self, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>This method can be used to take over properties of a parent <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L205-L213" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def inherit(self, parent):
    &#34;&#34;&#34;
    This method can be used to take over properties of a parent `refinery.lib.frame.Chunk`.
    &#34;&#34;&#34;
    self._path = parent._path
    self._view = parent._view
    for key, value in parent._meta.items():
        if key not in self._meta:
            self._meta[key] = value</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the serialized representation of this chunk.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L223-L227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pack(self):
    &#34;&#34;&#34;
    Return the serialized representation of this chunk.
    &#34;&#34;&#34;
    return msgpack.packb((self._path, self._view, self._meta, self._fill, self))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.frame.Framed"><code class="flex name class">
<span>class <span class="ident">Framed</span></span>
<span>(</span><span>action, stream, nested=0, filter=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A proxy interface to ingest and output framed data. It is given an <code>action</code> to be
performed for each elementary chunk of data, a <code>stream</code> of input data, and an integer
argument <code>nested</code> which specifies the relative amount of nesting to be performed
by the interface. This parameter should either be <code>1</code> if the interface should output
the results at an additional layer, <code>0</code> if the nesting depth of the data should
remain unchanged, and a negative amount if frame layers are to be collapsed. After
initialization, the <code><a title="refinery.lib.frame.Framed" href="#refinery.lib.frame.Framed">Framed</a></code> object is an iterator that yields
bytestrings which can be forwarded as the output of the operation with all framing
already taken care of.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L351-L480" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Framed:
    &#34;&#34;&#34;
    A proxy interface to ingest and output framed data. It is given an `action` to be
    performed for each elementary chunk of data, a `stream` of input data, and an integer
    argument `nested` which specifies the relative amount of nesting to be performed
    by the interface. This parameter should either be `1` if the interface should output
    the results at an additional layer, `0` if the nesting depth of the data should
    remain unchanged, and a negative amount if frame layers are to be collapsed. After
    initialization, the `refinery.lib.frame.Framed` object is an iterator that yields
    bytestrings which can be forwarded as the output of the operation with all framing
    already taken care of.
    &#34;&#34;&#34;
    def __init__(
        self,
        action: Callable[[bytearray], Iterable[Chunk]],
        stream: BinaryIO,
        nested: int = 0,
        filter: Optional[Callable[[Iterable[Chunk]], Iterable[Chunk]]] = None,
    ):
        self.unpack = FrameUnpacker(stream)
        self.action = action
        self.nested = nested
        self.filter = filter

    def _apply_filter(self) -&gt; Iterable[Chunk]:

        it = iter(self.unpack)

        def rewind():
            yield top
            yield from it

        try:
            top = next(it)
        except StopIteration:
            pass
        else:
            rw = rewind()
            yield from self.filter(rw) if top.scopable else rw

        if not self.unpack.eol:  # filter did not consume the iterable
            for _ in self.unpack:
                pass

    @property
    def unframed(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is true if the output data is not framed.
        &#34;&#34;&#34;
        return self.nested &lt; 1 and not self.unpack.framed

    @property
    def framebreak(self) -&gt; bool:
        &#34;&#34;&#34;
        This property will be true if the data generated by this framing interface
        is unframed, and the requested nesting was smaller than required to achieve
        this. In practice, it means that the user has provided more closing brakcets
        than were required to close all open frames.
        &#34;&#34;&#34;
        return self.nested + self.unpack.gauge &lt; 0

    def _generate_chunks(self, parent: Chunk):
        for item in self.action(parent):
            item = item.__copy__()
            item.inherit(parent)
            yield item

    def _generate_bytes(self, data: ByteString):
        yield from self.action(data)

    def __iter__(self):
        if self.unpack.finished:
            return

        if self.nested &gt; 0:
            yield MAGIC
            rest = (0,) * (self.nested - 1)
            while self.unpack.nextframe():
                for k, chunk in enumerate(self._apply_filter()):
                    if not chunk.visible:
                        yield chunk.nest(k, *rest).pack()
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.nest(k, *rest).pack()
            return

        elif not self.unpack.framed:
            for chunk in self._apply_filter():
                yield from self._generate_bytes(chunk)
            return

        if self.nested == 0:
            yield MAGIC
            while self.unpack.nextframe():
                for chunk in self._apply_filter():
                    if not chunk.visible:
                        yield chunk.pack()
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.pack()
            return

        gauge = max(self.unpack.gauge + self.nested, 0)

        if gauge:
            buffer = io.BytesIO()
            yield MAGIC
        while self.unpack.nextframe():
            while True:
                for chunk in self._apply_filter():
                    results = self._generate_bytes(chunk) if chunk.visible else (chunk,)
                    for result in results:
                        if not gauge:
                            yield result
                            continue
                        buffer.write(result)
                if self.unpack.peek[:gauge + 1] != self.unpack.trunk[:gauge + 1]:
                    break
                if not self.unpack.nextframe():
                    break
            if gauge:
                buffer.truncate(buffer.tell())
                collapsed = buffer.getvalue()
                try:
                    chunk[:] = collapsed
                    chunk.truncate(gauge)
                except NameError:
                    chunk = Chunk(collapsed, self.unpack.trunk[:gauge])
                yield chunk.pack()
                buffer.seek(0)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.frame.Framed.unframed"><code class="name">var <span class="ident">unframed</span></code></dt>
<dd>
<section class="desc"><p>This property is true if the output data is not framed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L395-L400" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def unframed(self) -&gt; bool:
    &#34;&#34;&#34;
    This property is true if the output data is not framed.
    &#34;&#34;&#34;
    return self.nested &lt; 1 and not self.unpack.framed</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Framed.framebreak"><code class="name">var <span class="ident">framebreak</span></code></dt>
<dd>
<section class="desc"><p>This property will be true if the data generated by this framing interface
is unframed, and the requested nesting was smaller than required to achieve
this. In practice, it means that the user has provided more closing brakcets
than were required to close all open frames.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L402-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def framebreak(self) -&gt; bool:
    &#34;&#34;&#34;
    This property will be true if the data generated by this framing interface
    is unframed, and the requested nesting was smaller than required to achieve
    this. In practice, it means that the user has provided more closing brakcets
    than were required to close all open frames.
    &#34;&#34;&#34;
    return self.nested + self.unpack.gauge &lt; 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker"><code class="flex name class">
<span>class <span class="ident">FrameUnpacker</span></span>
<span>(</span><span>stream)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides a unified interface to read both framed and raw input data from a stream. After
loading a framed input stream, the object provides an iterator over the first <strong>frame</strong> in
the bottom <strong>layer</strong> of the frame tree. Consider this doubly layered frame tree:</p>
<pre><code>[[FOO, BAR], [BOO, BAZ]]
</code></pre>
<p>The <code><a title="refinery.lib.frame.FrameUnpacker" href="#refinery.lib.frame.FrameUnpacker">FrameUnpacker</a></code> object will first be an iterator over the first frame
<code>[FOO, BAR]</code>. After consuming this iterator, the <code><a title="refinery.lib.frame.FrameUnpacker.nextframe" href="#refinery.lib.frame.FrameUnpacker.nextframe">FrameUnpacker.nextframe()</a></code>
method can be called to load the next frame, at which point the object will become an
iterator over <code>[BOO, BAZ]</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L265-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FrameUnpacker:
    &#34;&#34;&#34;
    Provides a unified interface to read both framed and raw input data from a stream. After
    loading a framed input stream, the object provides an iterator over the first **frame** in
    the bottom **layer** of the frame tree. Consider this doubly layered frame tree:

        [[FOO, BAR], [BOO, BAZ]]

    The `refinery.lib.frame.FrameUnpacker` object will first be an iterator over the first frame
    `[FOO, BAR]`. After consuming this iterator, the `refinery.lib.frame.FrameUnpacker.nextframe`
    method can be called to load the next frame, at which point the object will become an
    iterator over `[BOO, BAZ]`.
    &#34;&#34;&#34;
    def __init__(self, stream: Optional[BinaryIO]):
        import msgpack
        self.finished = False
        self.trunk = ()
        self._next = Chunk(bytearray(), ())
        buffer = stream and stream.read(len(MAGIC)) or B&#39;&#39;
        if buffer == MAGIC:
            self.framed = True
            self.stream = stream
            self.unpacker = msgpack.Unpacker(
                max_buffer_size=0xFFFFFFFF,
                use_list=False
            )
            self._advance()
            self.gauge = len(self._next.path)
        else:
            self.framed = False
            self.gauge = 0
            while buffer:
                self._next.extend(buffer)
                buffer = stream.read()

    def _advance(self) -&gt; None:
        while not self.finished:
            try:
                self._next = Chunk.unpack(self.unpacker)
                break
            except StopIteration:
                pass
            try:
                recv = self.stream.read1() or self.stream.read()
            except TypeError:
                recv = self.stream.read()
            if recv:
                self.unpacker.feed(recv)
                continue
            self.finished = True

    def nextframe(self) -&gt; bool:
        &#34;&#34;&#34;
        Once the iterator is consumed, calling this function will return `True` if
        and only if another frame with input data has been loaded, in which case
        the object will provide an iterator over the freshly loaded frame. If this
        function returns `False`, all input data has been consumed.
        &#34;&#34;&#34;
        if self.finished:
            return False
        self.trunk = self._next.path
        return True

    @property
    def eol(self) -&gt; bool:
        return self.trunk != self.peek

    @property
    def peek(self) -&gt; Tuple[int]:
        &#34;&#34;&#34;
        Contains the identifier of the next frame.
        &#34;&#34;&#34;
        return self._next.path

    def __iter__(self) -&gt; Iterable[Chunk]:
        if self.finished:
            return
        if not self.framed:
            yield self._next
            self.finished = True
            return
        while not self.finished and self.trunk == self._next.path:
            yield self._next
            self._advance()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.frame.FrameUnpacker.eol"><code class="name">var <span class="ident">eol</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L328-L330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eol(self) -&gt; bool:
    return self.trunk != self.peek</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.peek"><code class="name">var <span class="ident">peek</span></code></dt>
<dd>
<section class="desc"><p>Contains the identifier of the next frame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L332-L337" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def peek(self) -&gt; Tuple[int]:
    &#34;&#34;&#34;
    Contains the identifier of the next frame.
    &#34;&#34;&#34;
    return self._next.path</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.frame.FrameUnpacker.nextframe"><code class="name flex">
<span>def <span class="ident">nextframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Once the iterator is consumed, calling this function will return <code>True</code> if
and only if another frame with input data has been loaded, in which case
the object will provide an iterator over the freshly loaded frame. If this
function returns <code>False</code>, all input data has been consumed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/238a54e16c2e926f29dde73bb91a2e05be817b90/refinery/lib/frame.py#L316-L326" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nextframe(self) -&gt; bool:
    &#34;&#34;&#34;
    Once the iterator is consumed, calling this function will return `True` if
    and only if another frame with input data has been loaded, in which case
    the object will provide an iterator over the freshly loaded frame. If this
    function returns `False`, all input data has been consumed.
    &#34;&#34;&#34;
    if self.finished:
        return False
    self.trunk = self._next.path
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#simple-frame-example">Simple Frame Example</a></li>
<li><a href="#frame-layers">Frame Layers</a></li>
<li><a href="#adding-line-breaks-easily">Adding Line Breaks Easily</a></li>
<li><a href="#scoping">Scoping</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.frame.Chunk.unpack" href="#refinery.lib.frame.Chunk.unpack">unpack</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.set_next_scope" href="#refinery.lib.frame.Chunk.set_next_scope">set_next_scope</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.truncate" href="#refinery.lib.frame.Chunk.truncate">truncate</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.nest" href="#refinery.lib.frame.Chunk.nest">nest</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.inherit" href="#refinery.lib.frame.Chunk.inherit">inherit</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.pack" href="#refinery.lib.frame.Chunk.pack">pack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.frame.Framed" href="#refinery.lib.frame.Framed">Framed</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.frame.FrameUnpacker" href="#refinery.lib.frame.FrameUnpacker">FrameUnpacker</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.frame.FrameUnpacker.nextframe" href="#refinery.lib.frame.FrameUnpacker.nextframe">nextframe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>